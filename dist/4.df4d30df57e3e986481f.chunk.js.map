{"version":3,"sources":["webpack:///4.df4d30df57e3e986481f.chunk.js","webpack:///../node_modules/harmony-reflect/reflect.js","webpack:///../node_modules/webpack/buildin/global.js"],"names":["webpackJsonp","246","module","exports","__webpack_require__","global","isStandardAttribute","name","test","toPropertyDescriptor","obj","Object","TypeError","desc","enumerable","configurable","value","writable","getter","get","undefined","setter","set","isAccessorDescriptor","isDataDescriptor","isGenericDescriptor","toCompletePropertyDescriptor","internalDesc","isEmptyDescriptor","isEquivalentDescriptor","desc1","desc2","sameValue","x","y","normalizeAndCompletePropertyDescriptor","attributes","defineProperty","normalizePropertyDescriptor","isFixed","target","hasOwnProperty","call","isSealed","getOwnPropertyDescriptor","isSealedDesc","isCompatibleDescriptor","extensible","current","setIntegrityLevel","level","ownProps","Object_getOwnPropertyNames","pendingException","k","l","length","i","String","e","currentDesc","Reflect","preventExtensions","testIntegrityLevel","Object_isExtensible","Validator","handler","this","isObject","arg","type","safeWeakMapGet","map","key","makeUnwrapping0ArgMethod","primitive","builtin","vHandler","directProxies","isProxyArray","Array","isArray","WeakMap","prototype","v","Error","Object_getPrototypeOf","prim_preventExtensions","prim_isExtensible","isExtensible","prim_getPrototypeOf","getPrototypeOf","prim_getOwnPropertyDescriptor","prim_defineProperty","prim_defineProperties","defineProperties","prim_keys","keys","prim_getOwnPropertyNames","getOwnPropertyNames","prim_getOwnPropertySymbols","getOwnPropertySymbols","prim_assign","assign","prim_isArray","prim_concat","concat","prim_isPrototypeOf","isPrototypeOf","prim_hasOwnProperty","getTrap","trapName","trap","targetDesc","getPropertyDescriptor","has","val","descObj","success","delete","deleteProperty","res","ownKeys","trapResult","propNames","create","numProps","result","s","forEach","ownProp","state","allegedProto","setPrototypeOf","newProto","getPropertyNames","receiver","fixedDesc","enumerate","nxt","next","done","push","ownEnumerableProps","ownEnumerableProp","iterate","apply","thisBinding","args","construct","newTarget","subject","vhandler","seal","freeze","isFrozen","descs","names","noProxies","arguments","output","index","source","nextKey","valueOf","toString","Function","Date","vHandler2","slice","prim_setPrototypeOf","__proto__setter","protoDesc","proto","ownDesc","existingDesc","updateDesc","newDesc","idx","bind","Proxy","primCreate","primCreateFunction","createFunction","revokedHandler","proxy","revocable","revoke","_target","_handler","260","g","eval","window"],"mappings":"AAAAA,cAAc,IAERC,IACA,SAAUC,EAAQC,EAASC,ICHjC,SAAAC,IAyFA,SAAAA,GACA,YA2GA,SAAAC,GAAAC,GACA,2DAAAC,KAAAD,GAIA,QAAAE,GAAAC,GACA,GAAAC,OAAAD,OACA,SAAAE,WAAA,mDACAF,EAEA,IAAAG,KAKA,IAJA,cAAAH,KAA4BG,EAAAC,aAAAJ,EAAAI,YAC5B,gBAAAJ,KAA8BG,EAAAE,eAAAL,EAAAK,cAC9B,SAAAL,KAAuBG,EAAAG,MAAAN,EAAAM,OACvB,YAAAN,KAA0BG,EAAAI,WAAAP,EAAAO,UAC1B,OAAAP,GAAA,CACA,GAAAQ,GAAAR,EAAAS,GACA,QAAAC,KAAAF,GAAA,kBAAAA,GACA,SAAAN,WAAA,6EACAM,EAEAL,GAAAM,IAAAD,EAEA,UAAAR,GAAA,CACA,GAAAW,GAAAX,EAAAY,GACA,QAAAF,KAAAC,GAAA,kBAAAA,GACA,SAAAT,WAAA,6EACAS,EAEAR,GAAAS,IAAAD,EAEA,WAAAR,IAAA,OAAAA,MACA,SAAAA,IAAA,YAAAA,IACA,SAAAD,WAAA,yEACAF,EAGA,OAAAG,GAGA,QAAAU,GAAAV,GACA,WAAAO,KAAAP,IACA,OAAAA,IAAA,OAAAA,IAEA,QAAAW,GAAAX,GACA,WAAAO,KAAAP,IACA,SAAAA,IAAA,YAAAA,IAEA,QAAAY,GAAAZ,GACA,WAAAO,KAAAP,KACAU,EAAAV,KAAAW,EAAAX,IAGA,QAAAa,GAAAb,GACA,GAAAc,GAAAlB,EAAAI,EAUA,OATAY,GAAAE,IAAAH,EAAAG,IACA,SAAAA,KAAqCA,EAAAX,UAAAI,IACrC,YAAAO,KAAwCA,EAAAV,UAAA,KAExC,OAAAU,KAAmCA,EAAAR,QAAAC,IACnC,OAAAO,KAAmCA,EAAAL,QAAAF,KAEnC,cAAAO,KAAwCA,EAAAb,YAAA,GACxC,gBAAAa,KAA0CA,EAAAZ,cAAA,GAC1CY,EAGA,QAAAC,GAAAf,GACA,eAAAA,IACA,OAAAA,IACA,SAAAA,IACA,YAAAA,IACA,cAAAA,IACA,gBAAAA,IAGA,QAAAgB,GAAAC,EAAAC,GACA,MAAAC,GAAAF,EAAAX,IAAAY,EAAAZ,MACAa,EAAAF,EAAAR,IAAAS,EAAAT,MACAU,EAAAF,EAAAd,MAAAe,EAAAf,QACAgB,EAAAF,EAAAb,SAAAc,EAAAd,WACAe,EAAAF,EAAAhB,WAAAiB,EAAAjB,aACAkB,EAAAF,EAAAf,aAAAgB,EAAAhB,cAIA,QAAAiB,GAAAC,EAAAC,GACA,MAAAD,KAAAC,EAEA,IAAAD,GAAA,EAAAA,GAAA,EAAAC,EAQAD,OAAAC,MAaA,QAAAC,GAAAC,GACA,OAAAhB,KAAAgB,EAAA,CACA,GAAAvB,GAAAa,EAAAU,EAGA,QAAA7B,KAAA6B,GACA9B,EAAAC,IACAI,OAAA0B,eAAAxB,EAAAN,GACSS,MAAAoB,EAAA7B,GACTU,UAAA,EACAH,YAAA,EACAC,cAAA,GAGA,OAAAF,IAaA,QAAAyB,GAAAF,GACA,GAAAvB,GAAAJ,EAAA2B,EAGA,QAAA7B,KAAA6B,GACA9B,EAAAC,IACAI,OAAA0B,eAAAxB,EAAAN,GACSS,MAAAoB,EAAA7B,GACTU,UAAA,EACAH,YAAA,EACAC,cAAA,GAGA,OAAAF,GAmCA,QAAA0B,GAAAhC,EAAAiC,GACA,SAAYC,eAAAC,KAAAF,EAAAjC,GAEZ,QAAAoC,GAAApC,EAAAiC,GACA,GAAA3B,GAAAF,OAAAiC,yBAAAJ,EAAAjC,EACA,YAAAa,KAAAP,IACA,IAAAA,EAAAE,aAEA,QAAA8B,GAAAhC,GACA,WAAAO,KAAAP,IAAA,IAAAA,EAAAE,aAUA,QAAA+B,GAAAC,EAAAC,EAAAnC,GACA,OAAAO,KAAA4B,IAAA,IAAAD,EACA,QAEA,QAAA3B,KAAA4B,IAAA,IAAAD,EACA,QAEA,IAAAnB,EAAAf,GACA,QAEA,IAAAgB,EAAAmB,EAAAnC,GACA,QAEA,SAAAmC,EAAAjC,aAAA,CACA,QAAAF,EAAAE,aACA,QAEA,kBAAAF,MAAAC,aAAAkC,EAAAlC,WACA,SAGA,GAAAW,EAAAZ,GACA,QAEA,IAAAW,EAAAwB,KAAAxB,EAAAX,GACA,WAAAmC,EAAAjC,YAKA,IAAAS,EAAAwB,IAAAxB,EAAAX,GAAA,CACA,QAAAmC,EAAAjC,aAAA,CACA,QAAAiC,EAAA/B,WAAA,IAAAJ,EAAAI,SACA,QAEA,SAAA+B,EAAA/B,UACA,SAAAJ,KAAAmB,EAAAnB,EAAAG,MAAAgC,EAAAhC,OACA,SAIA,SAEA,GAAAO,EAAAyB,IAAAzB,EAAAV,KACA,IAAAmC,EAAAjC,aAAA,CACA,UAAAF,KAAAmB,EAAAnB,EAAAS,IAAA0B,EAAA1B,KACA,QAEA,WAAAT,KAAAmB,EAAAnB,EAAAM,IAAA6B,EAAA7B,KACA,SAIA,SAKA,QAAA8B,GAAAT,EAAAU,GACA,GAAAC,GAAAC,EAAAZ,GACAa,MAAAjC,EACA,eAAA8B,EAGA,OADAI,GADAC,GAAAJ,EAAAK,OAEAC,EAAA,EAAmBA,EAAAF,EAAOE,IAAA,CAC1BH,EAAAI,OAAAP,EAAAM,GACA,KACA9C,OAAA0B,eAAAG,EAAAc,GAA0CvC,cAAA,IACnC,MAAA4C,OACPvC,KAAAiC,IACAA,EAAAM,QAQA,QADAL,GADAC,GAAAJ,EAAAK,OAEAC,EAAA,EAAmBA,EAAAF,EAAOE,IAAA,CAC1BH,EAAAI,OAAAP,EAAAM,GACA,KACA,GAAAG,GAAAjD,OAAAiC,yBAAAJ,EAAAc,EACA,QAAAlC,KAAAwC,EAAA,CACA,GAAA/C,EAEAA,GADAU,EAAAqC,IACoB7C,cAAA,IAEAA,cAAA,EAAAE,UAAA,GAEpBN,OAAA0B,eAAAG,EAAAc,EAAAzC,IAEO,MAAA8C,OACPvC,KAAAiC,IACAA,EAAAM,IAKA,OAAAvC,KAAAiC,EACA,KAAAA,EAEA,OAAAQ,GAAAC,kBAAAtB,GAKA,QAAAuB,GAAAvB,EAAAU,GAEA,GADAc,EAAAxB,GACA,QAUA,QAFAc,GACAM,EAPAT,EAAAC,EAAAZ,GACAa,MAAAjC,GACAL,GAAA,EACAE,GAAA,EAEAsC,GAAAJ,EAAAK,OAGAC,EAAA,EAAiBA,EAAAF,EAAOE,IAAA,CACxBH,EAAAI,OAAAP,EAAAM,GACA,KACAG,EAAAjD,OAAAiC,yBAAAJ,EAAAc,GACAvC,KAAA6C,EAAA7C,aACAS,EAAAoC,KACA3C,KAAA2C,EAAA3C,UAEK,MAAA0C,OACLvC,KAAAiC,IACAA,EAAAM,EACA5C,GAAA,IAIA,OAAAK,KAAAiC,EACA,KAAAA,EAEA,mBAAAH,IAAA,IAAAjC,KAGA,IAAAF,EAqBA,QAAAkD,GAAAzB,EAAA0B,GAKAC,KAAA3B,SACA2B,KAAAD,UAohCA,QAAAE,GAAAC,GACA,GAAAC,SAAAD,EACA,kBAAAC,GAAA,OAAAD,GAAA,aAAAC,EAMA,QAAAC,GAAAC,EAAAC,GACA,MAAAL,GAAAK,GAAAD,EAAArD,IAAAsD,OAAArD,GAOA,QAAAsD,GAAAC,GACA,eAAAC,KACA,GAAAC,GAAAN,EAAAO,EAAAX,KACA,YAAA/C,KAAAyD,EACAD,EAAAlC,KAAAmC,EAAArC,QAEAmC,EAAAjC,KAAAyB,OA4DA,QAAAY,GAAAV,GACA,GAAAQ,GAAAN,EAAAO,EAAAT,EACA,YAAAjD,KAAAyD,GACAG,MAAAC,QAAAJ,EAAArC,QAr+CA,mBAAA0C,WACA7E,EAAA6E,QAAA,aACA7E,EAAA6E,QAAAC,WACAhE,IAAA,SAAAmC,KACAhC,IAAA,SAAAgC,EAAA8B,GAAwB,SAAAC,OAAA,2BAgKxB,IAwBArB,GACAsB,EACAlC,EA1BAmC,EAAA5E,OAAAmD,kBAGA0B,GAFA7E,OACAA,OACAA,OAAA8E,cAGAC,GAFA/E,OACAA,OACAA,OAAAgF,gBACAC,EAAAjF,OAAAiC,yBACAiD,EAAAlF,OAAA0B,eACAyD,EAAAnF,OAAAoF,iBACAC,EAAArF,OAAAsF,KACAC,EAAAvF,OAAAwF,oBACAC,EAAAzF,OAAA0F,sBACAC,EAAA3F,OAAA4F,OACAC,EAAAxB,MAAAC,QACAwB,EAAAzB,MAAAG,UAAAuB,OACAC,EAAAhG,OAAAwE,UAAAyB,cACAC,EAAAlG,OAAAwE,UAAA1C,cA0MAwB,GAAAkB,WASA2B,QAAA,SAAAC,GACA,GAAAC,GAAA7C,KAAAD,QAAA6C,EACA,QAAA3F,KAAA4F,EAAA,CAMA,qBAAAA,GACA,SAAApG,WAAAmG,EAAA,0BAAAC,EAGA,OAAAA,KAaApE,yBAAA,SAAArC,GAGA,GAAAyG,GAAA7C,KAAA2C,QAAA,2BACA,QAAA1F,KAAA4F,EACA,MAAAnD,GAAAjB,yBAAAuB,KAAA3B,OAAAjC,EAGAA,GAAAmD,OAAAnD,EACA,IAAAM,GAAAmG,EAAAtE,KAAAyB,KAAAD,QAAAC,KAAA3B,OAAAjC,EACAM,GAAAsB,EAAAtB,EAEA,IAAAoG,GAAAtG,OAAAiC,yBAAAuB,KAAA3B,OAAAjC,GACAwC,EAAApC,OAAA8E,aAAAtB,KAAA3B,OAEA,QAAApB,KAAAP,EAAA,CAsBA,IAAAkC,OACA3B,KAAA6F,EACA,SAAArG,WAAA,qCACAL,EAAA,+BAIA,QAAAa,KAAAb,IACAuC,EAAAC,EAAAkE,EAAApG,GACA,SAAAD,WAAA,gEACAL,EAAA,IAIA,SAAAM,EAAAE,aAAA,CACA,OAAAK,KAAA6F,IAAA,IAAAA,EAAAlG,aAMA,SAAAH,WACA,0FACAL,EAAA,IAEA,gBAAAM,KAAA,IAAAA,EAAAI,WACA,IAAAgG,EAAAhG,SAMA,SAAAL,WACA,sDAAAL,EACA,uCAKA,MAAAM,GA5DA,GAAAgC,EAAAoE,GACA,SAAArG,WAAA,4CAAAL,EACA,oBAEA,KAAAwC,OAAA3B,KAAA6F,EAKA,SAAArG,WAAA,wCAAAL,EACA,iDA+FA2G,sBAAA,SAAA3G,GACA,GAAA2D,GAAAC,IAEA,IAAAD,EAAAiD,IAAA5G,GAEA,OACAY,IAAA,WACA,MAAA+C,GAAA/C,IAAAgD,KAAA5D,IAEAe,IAAA,SAAA8F,GACA,GAAAlD,EAAA5C,IAAA6C,KAAA5D,EAAA6G,GACA,MAAAA,EAEA,UAAAxG,WAAA,wBAAAL,IAGAO,YAAA,EACAC,cAAA,IAQAsB,eAAA,SAAA9B,EAAAM,GAWA,GAAAmG,GAAA7C,KAAA2C,QAAA,iBACA,QAAA1F,KAAA4F,EAEA,MAAAnD,GAAAxB,eAAA8B,KAAA3B,OAAAjC,EAAAM,EAGAN,GAAAmD,OAAAnD,EACA,IAAA8G,GAAA/E,EAAAzB,GACAyG,EAAAN,EAAAtE,KAAAyB,KAAAD,QAAAC,KAAA3B,OAAAjC,EAAA8G,EAGA,UAFAC,OAEA,CAEA,GAAAL,GAAAtG,OAAAiC,yBAAAuB,KAAA3B,OAAAjC,GACAwC,EAAApC,OAAA8E,aAAAtB,KAAA3B,OAKA,KAAAO,OACA3B,KAAA6F,EACA,SAAArG,WAAA,2CACAL,EAAA,+BAIA,QAAAa,KAAA6F,EAAA,CACA,IAAAnE,EAAAC,EAAAkE,EAAApG,GACA,SAAAD,WAAA,gEACAL,EAAA,IAEA,IAAAiB,EAAAyF,KACA,IAAAA,EAAAlG,eACA,IAAAkG,EAAAhG,WACA,IAAAJ,EAAAE,eAAA,IAAAF,EAAAI,SAOA,SAAAL,WACA,oEACAL,EAAA,uCAKA,QAAAM,EAAAE,eAAA8B,EAAAoE,GAMA,SAAArG,WACA,uGAEAL,EAAA,KAKA,MAAA+G,IAMAxD,kBAAA,WACA,GAAAkD,GAAA7C,KAAA2C,QAAA,oBACA,QAAA1F,KAAA4F,EAEA,MAAAnD,GAAAC,kBAAAK,KAAA3B,OAGA,IAAA8E,GAAAN,EAAAtE,KAAAyB,KAAAD,QAAAC,KAAA3B,OAEA,KADA8E,QAEAtD,EAAAG,KAAA3B,QACA,SAAA5B,WAAA,qDACAuD,KAAA3B,OAGA,OAAA8E,IAMAC,OAAA,SAAAhH,GAEA,GAAAyG,GAAA7C,KAAA2C,QAAA,iBACA,QAAA1F,KAAA4F,EAEA,MAAAnD,GAAA2D,eAAArD,KAAA3B,OAAAjC,EAGAA,GAAAmD,OAAAnD,EACA,IAAAkH,GAAAT,EAAAtE,KAAAyB,KAAAD,QAAAC,KAAA3B,OAAAjC,EACAkH,MAEA,IAAAR,EACA,SAAAQ,EAAA,CAEA,OAAArG,MADA6F,EAAAtG,OAAAiC,yBAAAuB,KAAA3B,OAAAjC,MACA,IAAA0G,EAAAlG,aACA,SAAAH,WAAA,aAAAL,EAAA,6CAGA,QAAAa,KAAA6F,IAAAjD,EAAAG,KAAA3B,QAKA,SAAA5B,WACA,iDAAAL,EACA,gCAIA,MAAAkH,IAWAtB,oBAAA,WASA,MAAAhC,MAAAuD,WAoBAA,QAAA,WACA,GAAAV,GAAA7C,KAAA2C,QAAA,UACA,QAAA1F,KAAA4F,EAEA,MAAAnD,GAAA6D,QAAAvD,KAAA3B,OAUA,QAPAmF,GAAAX,EAAAtE,KAAAyB,KAAAD,QAAAC,KAAA3B,QAGAoF,EAAAjH,OAAAkH,OAAA,MACAC,GAAAH,EAAAnE,OACAuE,EAAA,GAAA/C,OAAA8C,GAEArE,EAAA,EAAmBA,EAAAqE,EAAcrE,IAAA,CACjC,GAAAuE,GAAAtE,OAAAiE,EAAAlE,GACA,KAAA9C,OAAA8E,aAAAtB,KAAA3B,UAAAD,EAAAyF,EAAA7D,KAAA3B,QAEA,SAAA5B,WAAA,4CACAoH,EAAA,+BAGAJ,GAAAI,IAAA,EACAD,EAAAtE,GAAAuE,EAGA,GAAA7E,GAAAC,EAAAe,KAAA3B,QACAA,EAAA2B,KAAA3B,MAoBA,OAnBAW,GAAA8E,QAAA,SAAAC,GACA,IAAAN,EAAAM,GAAA,CACA,GAAAvF,EAAAuF,EAAA1F,GACA,SAAA5B,WAAA,6DACAsH,EAAA,IAEA,KAAAvH,OAAA8E,aAAAjD,IACAD,EAAA2F,EAAA1F,GAMA,SAAA5B,WAAA,qDACAsH,EAAA,mDAKAH,GAOAtC,aAAA,WACA,GAAAuB,GAAA7C,KAAA2C,QAAA,eACA,QAAA1F,KAAA4F,EAEA,MAAAnD,GAAA4B,aAAAtB,KAAA3B,OAGA,IAAAuF,GAAAf,EAAAtE,KAAAyB,KAAAD,QAAAC,KAAA3B,OACAuF,MACA,IAAAI,GAAAnE,EAAAG,KAAA3B,OACA,IAAAuF,IAAAI,EACA,KAAAJ,GACA,GAAAnH,WAAA,sDACAuD,KAAA3B,QAEA,GAAA5B,WAAA,sDACAuD,KAAA3B,OAGA,OAAA2F,IAMAxC,eAAA,WACA,GAAAqB,GAAA7C,KAAA2C,QAAA,iBACA,QAAA1F,KAAA4F,EAEA,MAAAnD,GAAA8B,eAAAxB,KAAA3B,OAGA,IAAA4F,GAAApB,EAAAtE,KAAAyB,KAAAD,QAAAC,KAAA3B,OAEA,KAAAwB,EAAAG,KAAA3B,QAAA,CAEA,IAAAR,EAAAoG,EADA9C,EAAAnB,KAAA3B,SAEA,SAAA5B,WAAA,mCAAAuD,KAAA3B,QAIA,MAAA4F,IAOAC,eAAA,SAAAC,GACA,GAAAtB,GAAA7C,KAAA2C,QAAA,iBACA,QAAA1F,KAAA4F,EAEA,MAAAnD,GAAAwE,eAAAlE,KAAA3B,OAAA8F,EAGA,IAAAhB,GAAAN,EAAAtE,KAAAyB,KAAAD,QAAAC,KAAA3B,OAAA8F,EAGA,KADAhB,SACAtD,EAAAG,KAAA3B,QAAA,CAEA,IAAAR,EAAAsG,EADAhD,EAAAnB,KAAA3B,SAEA,SAAA5B,WAAA,mCAAAuD,KAAA3B,QAIA,MAAA8E,IAUAiB,iBAAA,WACA,SAAA3H,WAAA,wCAQAuG,IAAA,SAAA5G,GACA,GAAAyG,GAAA7C,KAAA2C,QAAA,MACA,QAAA1F,KAAA4F,EAEA,MAAAnD,GAAAsD,IAAAhD,KAAA3B,OAAAjC,EAGAA,GAAAmD,OAAAnD,EACA,IAAAkH,GAAAT,EAAAtE,KAAAyB,KAAAD,QAAAC,KAAA3B,OAAAjC,EAGA,UAFAkH,OAEA,CACA,GAAA9E,EAAApC,EAAA4D,KAAA3B,QACA,SAAA5B,WAAA,yDACAL,EAAA,+BAGA,KAAAI,OAAA8E,aAAAtB,KAAA3B,SACAD,EAAAhC,EAAA4D,KAAA3B,QAKA,SAAA5B,WAAA,wCAAAL,EACA,gDAQA,MAAAkH,IAQAtG,IAAA,SAAAqH,EAAAjI,GAaA,GAAAyG,GAAA7C,KAAA2C,QAAA,MACA,QAAA1F,KAAA4F,EAEA,MAAAnD,GAAA1C,IAAAgD,KAAA3B,OAAAjC,EAAAiI,EAGAjI,GAAAmD,OAAAnD,EACA,IAAAkH,GAAAT,EAAAtE,KAAAyB,KAAAD,QAAAC,KAAA3B,OAAAjC,EAAAiI,GAEAC,EAAA9H,OAAAiC,yBAAAuB,KAAA3B,OAAAjC,EAEA,QAAAa,KAAAqH,EACA,GAAAjH,EAAAiH,KACA,IAAAA,EAAA1H,eACA,IAAA0H,EAAAxH,UACA,IAAAe,EAAAyF,EAAAgB,EAAAzH,OACA,SAAAJ,WAAA,iFAEAL,EAAA,SAGA,IAAAgB,EAAAkH,KACA,IAAAA,EAAA1H,kBACAK,KAAAqH,EAAAtH,SACAC,KAAAqG,EACA,SAAA7G,WAAA,iEACAL,EAAA,mBAMA,OAAAkH,IAOAnG,IAAA,SAAAkH,EAAAjI,EAAA6G,GACA,GAAAJ,GAAA7C,KAAA2C,QAAA,MACA,QAAA1F,KAAA4F,EAEA,MAAAnD,GAAAvC,IAAA6C,KAAA3B,OAAAjC,EAAA6G,EAAAoB,EAGAjI,GAAAmD,OAAAnD,EACA,IAAAkH,GAAAT,EAAAtE,KAAAyB,KAAAD,QAAAC,KAAA3B,OAAAjC,EAAA6G,EAAAoB,EAIA,UAHAf,OAGA,CACA,GAAAgB,GAAA9H,OAAAiC,yBAAAuB,KAAA3B,OAAAjC,EACA,QAAAa,KAAAqH,EACA,GAAAjH,EAAAiH,KACA,IAAAA,EAAA1H,eACA,IAAA0H,EAAAxH,UACA,IAAAe,EAAAoF,EAAAqB,EAAAzH,OACA,SAAAJ,WAAA,4EAEAL,EAAA,SAGA,IAAAgB,EAAAkH,KACA,IAAAA,EAAA1H,kBACAK,KAAAqH,EAAAnH,IACA,SAAAV,WAAA,uBAAAL,EAAA,6BAOA,MAAAkH,IAcAiB,UAAA,WACA,GAAA1B,GAAA7C,KAAA2C,QAAA,YACA,QAAA1F,KAAA4F,EAAA,CAKA,IAHA,GAAAW,GAAA9D,EAAA6E,UAAAvE,KAAA3B,QACAuF,KACAY,EAAAhB,EAAAiB,QACAD,EAAAE,MACAd,EAAAe,KAAApF,OAAAiF,EAAA3H,QACA2H,EAAAhB,EAAAiB,MAEA,OAAAb,GAGA,GAAAJ,GAAAX,EAAAtE,KAAAyB,KAAAD,QAAAC,KAAA3B,OAEA,WAAAmF,OACAvG,KAAAuG,OACAvG,KAAAuG,EAAAiB,KACA,SAAAhI,WAAA,kDACA+G,EAcA,KAVA,GAAAC,GAAAjH,OAAAkH,OAAA,MAGAE,KAKAY,EAAAhB,EAAAiB,QAEAD,EAAAE,MAAA,CACA,GAAAb,GAAAtE,OAAAiF,EAAA3H,MACA,IAAA4G,EAAAI,GACA,SAAApH,WAAA,oDACAoH,EAAA,IAEAJ,GAAAI,IAAA,EACAD,EAAAe,KAAAd,GACAW,EAAAhB,EAAAiB,OAcA,GAAAG,GAAApI,OAAAsF,KAAA9B,KAAA3B,QACAA,EAAA2B,KAAA3B,MAsBA,OArBAuG,GAAAd,QAAA,SAAAe,GACA,IAAApB,EAAAoB,GAAA,CACA,GAAArG,EAAAqG,EAAAxG,GACA,SAAA5B,WAAA,0EAEAoI,EAAA,IAEA,KAAArI,OAAA8E,aAAAjD,IACAD,EAAAyG,EAAAxG,GAMA,SAAA5B,WAAA,wCACAoI,EAAA,mDAMAjB,GAMAkB,QAAAhF,EAAAkB,UAAAuD,UAgFAQ,MAAA,SAAA1G,EAAA2G,EAAAC,GACA,GAAApC,GAAA7C,KAAA2C,QAAA,QACA,QAAA1F,KAAA4F,EACA,MAAAnD,GAAAqF,MAAA1G,EAAA2G,EAAAC,EAGA,sBAAAjF,MAAA3B,OACA,MAAAwE,GAAAtE,KAAAyB,KAAAD,QAAA1B,EAAA2G,EAAAC,EAEA,UAAAxI,WAAA,UAAA4B,EAAA,uBAUA6G,UAAA,SAAA7G,EAAA4G,EAAAE,GACA,GAAAtC,GAAA7C,KAAA2C,QAAA,YACA,QAAA1F,KAAA4F,EACA,MAAAnD,GAAAwF,UAAA7G,EAAA4G,EAAAE,EAGA,sBAAA9G,GACA,SAAA5B,WAAA,QAAA4B,EAAA,qBAGA,QAAApB,KAAAkI,EACAA,EAAA9G,MAEA,sBAAA8G,GACA,SAAA1I,WAAA,QAAA0I,EAAA,qBAGA,OAAAtC,GAAAtE,KAAAyB,KAAAD,QAAA1B,EAAA4G,EAAAE,IAWA,IAAAxE,GAAA,GAAAI,QAIAvE,QAAAmD,kBAAA,SAAAyF,GACA,GAAAC,GAAA1E,EAAA3D,IAAAoI,EACA,QAAAnI,KAAAoI,EAAA,CACA,GAAAA,EAAA1F,oBACA,MAAAyF,EAEA,UAAA3I,WAAA,wBAAA2I,EAAA,aAGA,MAAAhE,GAAAgE,IAGA5I,OAAA8I,KAAA,SAAAF,GAEA,MADAtG,GAAAsG,EAAA,UACAA,GAEA5I,OAAA+I,OAAA,SAAAH,GAEA,MADAtG,GAAAsG,EAAA,UACAA,GAEA5I,OAAA8E,aAAAzB,EAAA,SAAAuF,GACA,GAAA1E,GAAAC,EAAA3D,IAAAoI,EACA,YAAAnI,KAAAyD,EACAA,EAAAY,eAEAD,EAAA+D,IAGA5I,OAAAgC,SAAA,SAAA4G,GACA,MAAAxF,GAAAwF,EAAA,WAEA5I,OAAAgJ,SAAA,SAAAJ,GACA,MAAAxF,GAAAwF,EAAA,WAEA5I,OAAAgF,eAAAL,EAAA,SAAAiE,GACA,GAAA1E,GAAAC,EAAA3D,IAAAoI,EACA,YAAAnI,KAAAyD,EACAA,EAAAc,iBAEAD,EAAA6D,IAUA5I,OAAAiC,yBAAA,SAAA2G,EAAAhJ,GACA,GAAAiJ,GAAA1E,EAAA3D,IAAAoI,EACA,YAAAnI,KAAAoI,EACAA,EAAA5G,yBAAArC,GAEAqF,EAAA2D,EAAAhJ,IAuBAI,OAAA0B,eAAA,SAAAkH,EAAAhJ,EAAAM,GACA,GAAA2I,GAAA1E,EAAA3D,IAAAoI,EACA,QAAAnI,KAAAoI,EAAA,CAGA,QADAA,EAAAnH,eAAA9B,EADA+B,EAAAzB,IAGA,SAAAD,WAAA,4BAAAL,EAAA,IAEA,OAAAgJ,GAEA,MAAA1D,GAAA0D,EAAAhJ,EAAAM,IAIAF,OAAAoF,iBAAA,SAAAwD,EAAAK,GACA,GAAAJ,GAAA1E,EAAA3D,IAAAoI,EACA,QAAAnI,KAAAoI,EAAA,CAEA,OADAK,GAAAlJ,OAAAsF,KAAA2D,GACAnG,EAAA,EAAmBA,EAAAoG,EAAArG,OAAkBC,IAAA,CACrC,GAAAlD,GAAAsJ,EAAApG,EAGA,SADA+F,EAAAnH,eAAA9B,EADA+B,EAAAsH,EAAArJ,KAGA,SAAAK,WAAA,4BAAAL,EAAA,KAGA,MAAAgJ,GAEA,MAAAzD,GAAAyD,EAAAK,IAIAjJ,OAAAsF,KAAA,SAAAsD,GACA,GAAA1E,GAAAC,EAAA3D,IAAAoI,EACA,QAAAnI,KAAAyD,EAAA,CAGA,OAFA6C,GAAA7C,EAAA6C,UACAK,KACAtE,EAAA,EAAmBA,EAAAiE,EAAAlE,OAAoBC,IAAA,CACvC,GAAAH,GAAAI,OAAAgE,EAAAjE,IACA5C,EAAAF,OAAAiC,yBAAA2G,EAAAjG,OACAlC,KAAAP,IAAA,IAAAA,EAAAC,YACAiH,EAAAe,KAAAxF,GAGA,MAAAyE,GAEA,MAAA/B,GAAAuD,IAIA5I,OAAAwF,oBAAA/C,EAAA,SAAAmG,GACA,GAAA1E,GAAAC,EAAA3D,IAAAoI,EACA,YAAAnI,KAAAyD,EACAA,EAAA6C,UAEAxB,EAAAqD,QAMAnI,KAAAgF,IACAzF,OAAA0F,sBAAA,SAAAkD,GAEA,WAAAnI,KADA0D,EAAA3D,IAAAoI,MAMAnD,EAAAmD,SAWAnI,KAAAkF,IACA3F,OAAA4F,OAAA,SAAA/D,GAIA,OADAsH,IAAA,EACArG,EAAA,EAAmBA,EAAAsG,UAAAvG,OAAsBC,IAAA,CAEzC,OAAArC,KADA0D,EAAA3D,IAAA4I,UAAAtG,IACA,CACAqG,GAAA,CACA,QAGA,GAAAA,EAEA,MAAAxD,GAAA4C,MAAAvI,OAAAoJ,UAKA,QAAA3I,KAAAoB,GAAA,OAAAA,EACA,SAAA5B,WAAA,6CAIA,QADAoJ,GAAArJ,OAAA6B,GACAyH,EAAA,EAAuBA,EAAAF,UAAAvG,OAA0ByG,IAAA,CACjD,GAAAC,GAAAH,UAAAE,EACA,QAAA7I,KAAA8I,GAAA,OAAAA,EACA,OAAAC,KAAAD,GACAA,EAAAzH,eAAA0H,KACAH,EAAAG,GAAAD,EAAAC,IAKA,MAAAH,KAgDArJ,OAAAwE,UAAAiF,QACA1F,EAAA/D,OAAAwE,UAAAiF,SACAzJ,OAAAwE,UAAAkF,SACA3F,EAAA/D,OAAAwE,UAAAkF,UACAC,SAAAnF,UAAAkF,SACA3F,EAAA4F,SAAAnF,UAAAkF,UACAE,KAAApF,UAAAkF,SACA3F,EAAA6F,KAAApF,UAAAkF,UAEA1J,OAAAwE,UAAAyB,cAAA,SAAAvC,GAOA,QACA,GAAAmG,GAAAjG,EAAAO,EAAAT,EACA,QAAAjD,KAAAoJ,EAQA,MAAA7D,GAAAjE,KAAAyB,KAAAE,EANA,YADAA,EAAAmG,EAAA7E,kBAEA,QACO,IAAA3D,EAAAqC,EAAAF,MACP,WAQAa,MAAAC,QAAA,SAAAsE,GACA,GAAA1E,GAAAN,EAAAO,EAAAyE,EACA,YAAAnI,KAAAyD,EACAG,MAAAC,QAAAJ,EAAArC,QAEAgE,EAAA+C,IAmBAvE,MAAAG,UAAAuB,OAAA,WAEA,OADAlD,GACAC,EAAA,EAAiBA,EAAAsG,UAAAvG,OAAsBC,IACvCsB,EAAAgF,UAAAtG,MACAD,EAAAuG,UAAAtG,GAAAD,OACAuG,UAAAtG,GAAAuB,MAAAG,UAAAsF,MAAA/H,KAAAqH,UAAAtG,GAAA,EAAAD,GAGA,OAAAiD,GAAAyC,MAAA/E,KAAA4F,WAKA,IAAAW,GAAA/J,OAAA0H,eAGAsC,EAAA,WACA,GAAAC,GAAAhF,EAAAjF,OAAAwE,UAAA,YACA,QAAA/D,KAAAwJ,GACA,kBAAAA,GAAAtJ,IACA,kBACA,SAAAV,WAAA,iDAMA,KACAgK,EAAAtJ,IAAAoB,YACG,MAAAiB,GACH,kBACA,SAAA/C,WAAA,kDAUA,MANAiF,GAAAlF,OAAAwE,UAAA,aACA7D,IAAA,SAAAgH,GACA,MAAA3H,QAAA0H,eAAAlE,KAAAxD,OAAA2H,OAIAsC,EAAAtJ,MAGAX,QAAA0H,eAAA,SAAA7F,EAAA8F,GACA,GAAApE,GAAAY,EAAA3D,IAAAqB,EACA,QAAApB,KAAA8C,EAAA,CACA,GAAAA,EAAAmE,eAAAC,GACA,MAAA9F,EAEA,UAAA5B,WAAA,qCAGA,IAAAoD,EAAAxB,GACA,SAAA5B,WAAA,iDACA4B,EAEA,IAAAkI,EACA,MAAAA,GAAAlI,EAAA8F,EAEA,IAAA3H,OAAA2H,QAAA,OAAAA,EACA,SAAA1H,WAAA,mDACA0H,EAIA,OADAqC,GAAAjI,KAAAF,EAAA8F,GACA9F,GAIA7B,OAAAwE,UAAA1C,eAAA,SAAAlC,GACA,GAAA2D,GAAAK,EAAAO,EAAAX,KACA,QAAA/C,KAAA8C,EAAA,CAEA,WAAA9C,KADA8C,EAAAtB,yBAAArC,GAGA,MAAAsG,GAAAnE,KAAAyB,KAAA5D,GAOA,IAAAsD,GAAAxD,EAAAwD,SACAjB,yBAAA,SAAAJ,EAAAjC,GACA,MAAAI,QAAAiC,yBAAAJ,EAAAjC,IAEA8B,eAAA,SAAAG,EAAAjC,EAAAM,GAGA,GAAAqD,GAAAY,EAAA3D,IAAAqB,EACA,QAAApB,KAAA8C,EACA,MAAAA,GAAA7B,eAAAG,EAAAjC,EAAAM,EAQA,IAAAmC,GAAArC,OAAAiC,yBAAAJ,EAAAjC,GACAwC,EAAApC,OAAA8E,aAAAjD,EACA,QAAApB,KAAA4B,IAAA,IAAAD,EACA,QAEA,QAAA3B,KAAA4B,IAAA,IAAAD,EAEA,MADApC,QAAA0B,eAAAG,EAAAjC,EAAAM,IACA,CAEA,IAAAe,EAAAf,GACA,QAEA,IAAAgB,EAAAmB,EAAAnC,GACA,QAEA,SAAAmC,EAAAjC,aAAA,CACA,QAAAF,EAAAE,aACA,QAEA,kBAAAF,MAAAC,aAAAkC,EAAAlC,WACA,SAGA,GAAAW,EAAAZ,QAEK,IAAAW,EAAAwB,KAAAxB,EAAAX,IACL,QAAAmC,EAAAjC,aACA,aAEK,IAAAS,EAAAwB,IAAAxB,EAAAX,IACL,QAAAmC,EAAAjC,aAAA,CACA,QAAAiC,EAAA/B,WAAA,IAAAJ,EAAAI,SACA,QAEA,SAAA+B,EAAA/B,UACA,SAAAJ,KAAAmB,EAAAnB,EAAAG,MAAAgC,EAAAhC,OACA,cAIK,IAAAO,EAAAyB,IAAAzB,EAAAV,KACL,IAAAmC,EAAAjC,aAAA,CACA,UAAAF,KAAAmB,EAAAnB,EAAAS,IAAA0B,EAAA1B,KACA,QAEA,WAAAT,KAAAmB,EAAAnB,EAAAM,IAAA6B,EAAA7B,KACA,SAKA,MADAR,QAAA0B,eAAAG,EAAAjC,EAAAM,IACA,GAEA2G,eAAA,SAAAhF,EAAAjC,GACA,GAAA2D,GAAAY,EAAA3D,IAAAqB,EACA,QAAApB,KAAA8C,EACA,MAAAA,GAAAqD,OAAAhH,EAGA,IAAAM,GAAAF,OAAAiC,yBAAAJ,EAAAjC,EACA,YAAAa,KAAAP,IAGA,IAAAA,EAAAE,qBACAyB,GAAAjC,IACA,IAIAoF,eAAA,SAAAnD,GACA,MAAA7B,QAAAgF,eAAAnD,IAEA6F,eAAA,SAAA7F,EAAA8F,GAEA,GAAApE,GAAAY,EAAA3D,IAAAqB,EACA,QAAApB,KAAA8C,EACA,MAAAA,GAAAmE,eAAAC,EAGA,IAAA3H,OAAA2H,QAAA,OAAAA,EACA,SAAA1H,WAAA,mDACA0H,EAGA,KAAAtE,EAAAxB,GACA,QAIA,IAAAR,EADArB,OAAAgF,eAAAnD,GACA8F,GACA,QAGA,IAAAoC,EACA,IAEA,MADAA,GAAAlI,EAAA8F,IACA,EACO,MAAA3E,GACP,SAKA,MADAgH,GAAAjI,KAAAF,EAAA8F,IACA,GAEAxE,kBAAA,SAAAtB,GACA,GAAA0B,GAAAY,EAAA3D,IAAAqB,EACA,YAAApB,KAAA8C,EACAA,EAAAJ,qBAEAyB,EAAA/C,IACA,IAEAiD,aAAA,SAAAjD,GACA,MAAA7B,QAAA8E,aAAAjD,IAEA2E,IAAA,SAAA3E,EAAAjC,GACA,MAAAA,KAAAiC,IAEArB,IAAA,SAAAqB,EAAAjC,EAAAiI,GACAA,KAAAhG,CAGA,IAAA0B,GAAAY,EAAA3D,IAAAqB,EACA,QAAApB,KAAA8C,EACA,MAAAA,GAAA/C,IAAAqH,EAAAjI,EAGA,IAAAM,GAAAF,OAAAiC,yBAAAJ,EAAAjC,EACA,QAAAa,KAAAP,EAAA,CACA,GAAAgK,GAAAlK,OAAAgF,eAAAnD,EACA,WAAAqI,EACA,MAEA,OAAAhH,GAAA1C,IAAA0J,EAAAtK,EAAAiI,GAEA,MAAAhH,GAAAX,GACAA,EAAAG,UAGAI,KADAP,EAAAM,IAIAN,EAAAM,IAAAuB,KAAA8F,OAHA,IAOAlH,IAAA,SAAAkB,EAAAjC,EAAAS,EAAAwH,GACAA,KAAAhG,CAGA,IAAA0B,GAAAY,EAAA3D,IAAAqB,EACA,QAAApB,KAAA8C,EACA,MAAAA,GAAA5C,IAAAkH,EAAAjI,EAAAS,EAKA,IAAA8J,GAAAnK,OAAAiC,yBAAAJ,EAAAjC,EAEA,QAAAa,KAAA0J,EAAA,CAEA,GAAAD,GAAAlK,OAAAgF,eAAAnD,EAEA,WAAAqI,EAEA,MAAAhH,GAAAvC,IAAAuJ,EAAAtK,EAAAS,EAAAwH,EAQAsC,IACS9J,UAAAI,GACTH,UAAA,EACAH,YAAA,EACAC,cAAA,GAIA,GAAAQ,EAAAuJ,GAAA,CACA,GAAAzJ,GAAAyJ,EAAAxJ,GACA,YAAAF,KAAAC,IACAA,EAAAqB,KAAA8F,EAAAxH,IACA,GAGA,QAAA8J,EAAA7J,SAAA,QAIA,IAAA8J,GAAApK,OAAAiC,yBAAA4F,EAAAjI,EACA,QAAAa,KAAA2J,EAAA,CACA,GAAAC,IACShK,QAITC,SAAA8J,EAAA9J,SACAH,WAAAiK,EAAAjK,WACAC,aAAAgK,EAAAhK,aAEA,OADAJ,QAAA0B,eAAAmG,EAAAjI,EAAAyK,IACA,EAEA,IAAArK,OAAA8E,aAAA+C,GAAA,QACA,IAAAyC,IACSjK,QACTC,UAAA,EACAH,YAAA,EACAC,cAAA,EAEA,OADAJ,QAAA0B,eAAAmG,EAAAjI,EAAA0K,IACA,GAcAvC,UAAA,SAAAlG,GACA,GACAuF,GADA7D,EAAAY,EAAA3D,IAAAqB,EAEA,QAAApB,KAAA8C,EAIA6D,EAAA7D,EAAAwE,UAAAxE,EAAA1B,YACK,CACLuF,IACA,QAAAxH,KAAAiC,GAAgCuF,EAAAe,KAAAvI,GAEhC,GAAAgD,IAAAwE,EAAAvE,OACA0H,EAAA,CACA,QACAtC,KAAA,WACA,MAAAsC,KAAA3H,GAA+BsF,MAAA,IACfA,MAAA,EAAA7H,MAAA+G,EAAAmD,SAMhBxD,QAAA,SAAAlF,GACA,MAAAY,GAAAZ,IAEA0G,MAAA,SAAA1G,EAAAgG,EAAAY,GAEA,MAAAkB,UAAAnF,UAAA+D,MAAAxG,KAAAF,EAAAgG,EAAAY,IAEAC,UAAA,SAAA7G,EAAA4G,EAAAE,GAIA,GAAApF,GAAAY,EAAA3D,IAAAqB,EACA,QAAApB,KAAA8C,EACA,MAAAA,GAAAmF,UAAAnF,EAAA1B,OAAA4G,EAAAE,EAGA,sBAAA9G,GACA,SAAA5B,WAAA,6BAAA4B,EAEA,QAAApB,KAAAkI,EACAA,EAAA9G,MAEA,sBAAA8G,GACA,SAAA1I,WAAA,gCAAA4B,EAIA,YAAA8H,SAAAnF,UAAAgG,KAAAjC,MAAAI,GAAA,MAAA5C,OAAA0C,MAMA,uBAAAgC,YACA,KAAAA,MAAAvD,OAAA,CAEA,GAAAwD,GAAAD,MAAAvD,OACAyD,EAAAF,MAAAG,eAEAC,EAAAH,GACAlK,IAAA,WAAqB,SAAAP,WAAA,sBAGrBP,GAAA+K,MAAA,SAAA5I,EAAA0B,GAEA,GAAAvD,OAAA6B,OACA,SAAA5B,WAAA,yCAAA4B,EAGA,IAAA7B,OAAAuD,OACA,SAAAtD,WAAA,0CAAAsD,EAGA,IACAuH,GADA5G,EAAA,GAAAZ,GAAAzB,EAAA0B,EAkBA,OAfAuH,GADA,kBAAAjJ,GACA8I,EAAAzG,EAEA,WACA,GAAAuE,GAAApE,MAAAG,UAAAsF,MAAA/H,KAAAqH,UACA,OAAAlF,GAAAqE,MAAA1G,EAAA2B,KAAAiF,IAGA,WACA,GAAAA,GAAApE,MAAAG,UAAAsF,MAAA/H,KAAAqH,UACA,OAAAlF,GAAAwE,UAAA7G,EAAA4G,KAGAiC,EAAAxG,EAAAlE,OAAAgF,eAAAnD,IAEAsC,EAAAxD,IAAAmK,EAAA5G,GACA4G,GAGApL,EAAA+K,MAAAM,UAAA,SAAAlJ,EAAA0B,GACA,GAAAuH,GAAA,GAAAL,OAAA5I,EAAA0B,EASA,QAAYuH,QAAAE,OARZ,WACA,GAAA9G,GAAAC,EAAA3D,IAAAsK,EACA,QAAA5G,IACAA,EAAArC,OAAA,KACAqC,EAAAX,QAAAsH,MAWAnL,EAAA+K,MAAAvD,OAAAwD,EACAhL,EAAA+K,MAAAG,eAAAD,MAIA,mBAAAF,SAEA/K,EAAA+K,MAAA,SAAAQ,EAAAC,GACA,SAAAxG,OAAA,0GAUA1E,QAAAsF,KAAApC,GAAAoE,QAAA,SAAAxD,GACAtE,EAAAsE,GAAAZ,EAAAY,MAKCpE,KDM4BqC,KAAKvC,EAASC,EAAoB,OAIzD0L,IACA,SAAU5L,EAAQC,GExoExB,GAAA4L,EAGAA,GAAA,WACA,MAAA5H,QAGA,KAEA4H,KAAAzB,SAAA,qBAAA0B,MAAA,QACC,MAAArI,GAED,gBAAAsI,UACAF,EAAAE,QAOA/L,EAAAC,QAAA4L","file":"4.df4d30df57e3e986481f.chunk.js","sourcesContent":["webpackJsonp([4],{\n\n/***/ 246:\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(global) {// Copyright (C) 2011-2012 Software Languages Lab, Vrije Universiteit Brussel\n// This code is dual-licensed under both the Apache License and the MPL\n\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/* Version: MPL 1.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is a shim for the ES-Harmony reflection module\n *\n * The Initial Developer of the Original Code is\n * Tom Van Cutsem, Vrije Universiteit Brussel.\n * Portions created by the Initial Developer are Copyright (C) 2011-2012\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *\n */\n\n // ----------------------------------------------------------------------------\n\n // This file is a polyfill for the upcoming ECMAScript Reflect API,\n // including support for Proxies. See the draft specification at:\n // http://wiki.ecmascript.org/doku.php?id=harmony:reflect_api\n // http://wiki.ecmascript.org/doku.php?id=harmony:direct_proxies\n\n // For an implementation of the Handler API, see handlers.js, which implements:\n // http://wiki.ecmascript.org/doku.php?id=harmony:virtual_object_api\n\n // This implementation supersedes the earlier polyfill at:\n // code.google.com/p/es-lab/source/browse/trunk/src/proxies/DirectProxies.js\n\n // This code was tested on tracemonkey / Firefox 12\n//  (and should run fine on older Firefox versions starting with FF4)\n // The code also works correctly on\n //   v8 --harmony_proxies --harmony_weakmaps (v3.6.5.1)\n\n // Language Dependencies:\n //  - ECMAScript 5/strict\n //  - \"old\" (i.e. non-direct) Harmony Proxies\n //  - Harmony WeakMaps\n // Patches:\n //  - Object.{freeze,seal,preventExtensions}\n //  - Object.{isFrozen,isSealed,isExtensible}\n //  - Object.getPrototypeOf\n //  - Object.keys\n //  - Object.prototype.valueOf\n //  - Object.prototype.isPrototypeOf\n //  - Object.prototype.toString\n //  - Object.prototype.hasOwnProperty\n //  - Object.getOwnPropertyDescriptor\n //  - Object.defineProperty\n //  - Object.defineProperties\n //  - Object.getOwnPropertyNames\n //  - Object.getOwnPropertySymbols\n //  - Object.getPrototypeOf\n //  - Object.setPrototypeOf\n //  - Object.assign\n //  - Function.prototype.toString\n //  - Date.prototype.toString\n //  - Array.isArray\n //  - Array.prototype.concat\n //  - Proxy\n // Adds new globals:\n //  - Reflect\n\n // Direct proxies can be created via Proxy(target, handler)\n\n // ----------------------------------------------------------------------------\n\n(function(global){ // function-as-module pattern\n\"use strict\";\n\n// === Direct Proxies: Invariant Enforcement ===\n\n// Direct proxies build on non-direct proxies by automatically wrapping\n// all user-defined proxy handlers in a Validator handler that checks and\n// enforces ES5 invariants.\n\n// A direct proxy is a proxy for an existing object called the target object.\n\n// A Validator handler is a wrapper for a target proxy handler H.\n// The Validator forwards all operations to H, but additionally\n// performs a number of integrity checks on the results of some traps,\n// to make sure H does not violate the ES5 invariants w.r.t. non-configurable\n// properties and non-extensible, sealed or frozen objects.\n\n// For each property that H exposes as own, non-configurable\n// (e.g. by returning a descriptor from a call to getOwnPropertyDescriptor)\n// the Validator handler defines those properties on the target object.\n// When the proxy becomes non-extensible, also configurable own properties\n// are checked against the target.\n// We will call properties that are defined on the target object\n// \"fixed properties\".\n\n// We will name fixed non-configurable properties \"sealed properties\".\n// We will name fixed non-configurable non-writable properties \"frozen\n// properties\".\n\n// The Validator handler upholds the following invariants w.r.t. non-configurability:\n// - getOwnPropertyDescriptor cannot report sealed properties as non-existent\n// - getOwnPropertyDescriptor cannot report incompatible changes to the\n//   attributes of a sealed property (e.g. reporting a non-configurable\n//   property as configurable, or reporting a non-configurable, non-writable\n//   property as writable)\n// - getPropertyDescriptor cannot report sealed properties as non-existent\n// - getPropertyDescriptor cannot report incompatible changes to the\n//   attributes of a sealed property. It _can_ report incompatible changes\n//   to the attributes of non-own, inherited properties.\n// - defineProperty cannot make incompatible changes to the attributes of\n//   sealed properties\n// - deleteProperty cannot report a successful deletion of a sealed property\n// - hasOwn cannot report a sealed property as non-existent\n// - has cannot report a sealed property as non-existent\n// - get cannot report inconsistent values for frozen data\n//   properties, and must report undefined for sealed accessors with an\n//   undefined getter\n// - set cannot report a successful assignment for frozen data\n//   properties or sealed accessors with an undefined setter.\n// - get{Own}PropertyNames lists all sealed properties of the target.\n// - keys lists all enumerable sealed properties of the target.\n// - enumerate lists all enumerable sealed properties of the target.\n// - if a property of a non-extensible proxy is reported as non-existent,\n//   then it must forever be reported as non-existent. This applies to\n//   own and inherited properties and is enforced in the\n//   deleteProperty, get{Own}PropertyDescriptor, has{Own},\n//   get{Own}PropertyNames, keys and enumerate traps\n\n// Violation of any of these invariants by H will result in TypeError being\n// thrown.\n\n// Additionally, once Object.preventExtensions, Object.seal or Object.freeze\n// is invoked on the proxy, the set of own property names for the proxy is\n// fixed. Any property name that is not fixed is called a 'new' property.\n\n// The Validator upholds the following invariants regarding extensibility:\n// - getOwnPropertyDescriptor cannot report new properties as existent\n//   (it must report them as non-existent by returning undefined)\n// - defineProperty cannot successfully add a new property (it must reject)\n// - getOwnPropertyNames cannot list new properties\n// - hasOwn cannot report true for new properties (it must report false)\n// - keys cannot list new properties\n\n// Invariants currently not enforced:\n// - getOwnPropertyNames lists only own property names\n// - keys lists only enumerable own property names\n// Both traps may list more property names than are actually defined on the\n// target.\n\n// Invariants with regard to inheritance are currently not enforced.\n// - a non-configurable potentially inherited property on a proxy with\n//   non-mutable ancestry cannot be reported as non-existent\n// (An object with non-mutable ancestry is a non-extensible object whose\n// [[Prototype]] is either null or an object with non-mutable ancestry.)\n\n// Changes in Handler API compared to previous harmony:proxies, see:\n// http://wiki.ecmascript.org/doku.php?id=strawman:direct_proxies\n// http://wiki.ecmascript.org/doku.php?id=harmony:direct_proxies\n\n// ----------------------------------------------------------------------------\n\n// ---- WeakMap polyfill ----\n\n// TODO: find a proper WeakMap polyfill\n\n// define an empty WeakMap so that at least the Reflect module code\n// will work in the absence of WeakMaps. Proxy emulation depends on\n// actual WeakMaps, so will not work with this little shim.\nif (typeof WeakMap === \"undefined\") {\n  global.WeakMap = function(){};\n  global.WeakMap.prototype = {\n    get: function(k) { return undefined; },\n    set: function(k,v) { throw new Error(\"WeakMap not supported\"); }\n  };\n}\n\n// ---- Normalization functions for property descriptors ----\n\nfunction isStandardAttribute(name) {\n  return /^(get|set|value|writable|enumerable|configurable)$/.test(name);\n}\n\n// Adapted from ES5 section 8.10.5\nfunction toPropertyDescriptor(obj) {\n  if (Object(obj) !== obj) {\n    throw new TypeError(\"property descriptor should be an Object, given: \"+\n                        obj);\n  }\n  var desc = {};\n  if ('enumerable' in obj) { desc.enumerable = !!obj.enumerable; }\n  if ('configurable' in obj) { desc.configurable = !!obj.configurable; }\n  if ('value' in obj) { desc.value = obj.value; }\n  if ('writable' in obj) { desc.writable = !!obj.writable; }\n  if ('get' in obj) {\n    var getter = obj.get;\n    if (getter !== undefined && typeof getter !== \"function\") {\n      throw new TypeError(\"property descriptor 'get' attribute must be \"+\n                          \"callable or undefined, given: \"+getter);\n    }\n    desc.get = getter;\n  }\n  if ('set' in obj) {\n    var setter = obj.set;\n    if (setter !== undefined && typeof setter !== \"function\") {\n      throw new TypeError(\"property descriptor 'set' attribute must be \"+\n                          \"callable or undefined, given: \"+setter);\n    }\n    desc.set = setter;\n  }\n  if ('get' in desc || 'set' in desc) {\n    if ('value' in desc || 'writable' in desc) {\n      throw new TypeError(\"property descriptor cannot be both a data and an \"+\n                          \"accessor descriptor: \"+obj);\n    }\n  }\n  return desc;\n}\n\nfunction isAccessorDescriptor(desc) {\n  if (desc === undefined) return false;\n  return ('get' in desc || 'set' in desc);\n}\nfunction isDataDescriptor(desc) {\n  if (desc === undefined) return false;\n  return ('value' in desc || 'writable' in desc);\n}\nfunction isGenericDescriptor(desc) {\n  if (desc === undefined) return false;\n  return !isAccessorDescriptor(desc) && !isDataDescriptor(desc);\n}\n\nfunction toCompletePropertyDescriptor(desc) {\n  var internalDesc = toPropertyDescriptor(desc);\n  if (isGenericDescriptor(internalDesc) || isDataDescriptor(internalDesc)) {\n    if (!('value' in internalDesc)) { internalDesc.value = undefined; }\n    if (!('writable' in internalDesc)) { internalDesc.writable = false; }\n  } else {\n    if (!('get' in internalDesc)) { internalDesc.get = undefined; }\n    if (!('set' in internalDesc)) { internalDesc.set = undefined; }\n  }\n  if (!('enumerable' in internalDesc)) { internalDesc.enumerable = false; }\n  if (!('configurable' in internalDesc)) { internalDesc.configurable = false; }\n  return internalDesc;\n}\n\nfunction isEmptyDescriptor(desc) {\n  return !('get' in desc) &&\n         !('set' in desc) &&\n         !('value' in desc) &&\n         !('writable' in desc) &&\n         !('enumerable' in desc) &&\n         !('configurable' in desc);\n}\n\nfunction isEquivalentDescriptor(desc1, desc2) {\n  return sameValue(desc1.get, desc2.get) &&\n         sameValue(desc1.set, desc2.set) &&\n         sameValue(desc1.value, desc2.value) &&\n         sameValue(desc1.writable, desc2.writable) &&\n         sameValue(desc1.enumerable, desc2.enumerable) &&\n         sameValue(desc1.configurable, desc2.configurable);\n}\n\n// copied from http://wiki.ecmascript.org/doku.php?id=harmony:egal\nfunction sameValue(x, y) {\n  if (x === y) {\n    // 0 === -0, but they are not identical\n    return x !== 0 || 1 / x === 1 / y;\n  }\n\n  // NaN !== NaN, but they are identical.\n  // NaNs are the only non-reflexive value, i.e., if x !== x,\n  // then x is a NaN.\n  // isNaN is broken: it converts its argument to number, so\n  // isNaN(\"foo\") => true\n  return x !== x && y !== y;\n}\n\n/**\n * Returns a fresh property descriptor that is guaranteed\n * to be complete (i.e. contain all the standard attributes).\n * Additionally, any non-standard enumerable properties of\n * attributes are copied over to the fresh descriptor.\n *\n * If attributes is undefined, returns undefined.\n *\n * See also: http://wiki.ecmascript.org/doku.php?id=harmony:proxies_semantics\n */\nfunction normalizeAndCompletePropertyDescriptor(attributes) {\n  if (attributes === undefined) { return undefined; }\n  var desc = toCompletePropertyDescriptor(attributes);\n  // Note: no need to call FromPropertyDescriptor(desc), as we represent\n  // \"internal\" property descriptors as proper Objects from the start\n  for (var name in attributes) {\n    if (!isStandardAttribute(name)) {\n      Object.defineProperty(desc, name,\n        { value: attributes[name],\n          writable: true,\n          enumerable: true,\n          configurable: true });\n    }\n  }\n  return desc;\n}\n\n/**\n * Returns a fresh property descriptor whose standard\n * attributes are guaranteed to be data properties of the right type.\n * Additionally, any non-standard enumerable properties of\n * attributes are copied over to the fresh descriptor.\n *\n * If attributes is undefined, will throw a TypeError.\n *\n * See also: http://wiki.ecmascript.org/doku.php?id=harmony:proxies_semantics\n */\nfunction normalizePropertyDescriptor(attributes) {\n  var desc = toPropertyDescriptor(attributes);\n  // Note: no need to call FromGenericPropertyDescriptor(desc), as we represent\n  // \"internal\" property descriptors as proper Objects from the start\n  for (var name in attributes) {\n    if (!isStandardAttribute(name)) {\n      Object.defineProperty(desc, name,\n        { value: attributes[name],\n          writable: true,\n          enumerable: true,\n          configurable: true });\n    }\n  }\n  return desc;\n}\n\n// store a reference to the real ES5 primitives before patching them later\nvar prim_preventExtensions =        Object.preventExtensions,\n    prim_seal =                     Object.seal,\n    prim_freeze =                   Object.freeze,\n    prim_isExtensible =             Object.isExtensible,\n    prim_isSealed =                 Object.isSealed,\n    prim_isFrozen =                 Object.isFrozen,\n    prim_getPrototypeOf =           Object.getPrototypeOf,\n    prim_getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor,\n    prim_defineProperty =           Object.defineProperty,\n    prim_defineProperties =         Object.defineProperties,\n    prim_keys =                     Object.keys,\n    prim_getOwnPropertyNames =      Object.getOwnPropertyNames,\n    prim_getOwnPropertySymbols =    Object.getOwnPropertySymbols,\n    prim_assign =                   Object.assign,\n    prim_isArray =                  Array.isArray,\n    prim_concat =                   Array.prototype.concat,\n    prim_isPrototypeOf =            Object.prototype.isPrototypeOf,\n    prim_hasOwnProperty =           Object.prototype.hasOwnProperty;\n\n// these will point to the patched versions of the respective methods on\n// Object. They are used within this module as the \"intrinsic\" bindings\n// of these methods (i.e. the \"original\" bindings as defined in the spec)\nvar Object_isFrozen,\n    Object_isSealed,\n    Object_isExtensible,\n    Object_getPrototypeOf,\n    Object_getOwnPropertyNames;\n\n/**\n * A property 'name' is fixed if it is an own property of the target.\n */\nfunction isFixed(name, target) {\n  return ({}).hasOwnProperty.call(target, name);\n}\nfunction isSealed(name, target) {\n  var desc = Object.getOwnPropertyDescriptor(target, name);\n  if (desc === undefined) { return false; }\n  return desc.configurable === false;\n}\nfunction isSealedDesc(desc) {\n  return desc !== undefined && desc.configurable === false;\n}\n\n/**\n * Performs all validation that Object.defineProperty performs,\n * without actually defining the property. Returns a boolean\n * indicating whether validation succeeded.\n *\n * Implementation transliterated from ES5.1 section 8.12.9\n */\nfunction isCompatibleDescriptor(extensible, current, desc) {\n  if (current === undefined && extensible === false) {\n    return false;\n  }\n  if (current === undefined && extensible === true) {\n    return true;\n  }\n  if (isEmptyDescriptor(desc)) {\n    return true;\n  }\n  if (isEquivalentDescriptor(current, desc)) {\n    return true;\n  }\n  if (current.configurable === false) {\n    if (desc.configurable === true) {\n      return false;\n    }\n    if ('enumerable' in desc && desc.enumerable !== current.enumerable) {\n      return false;\n    }\n  }\n  if (isGenericDescriptor(desc)) {\n    return true;\n  }\n  if (isDataDescriptor(current) !== isDataDescriptor(desc)) {\n    if (current.configurable === false) {\n      return false;\n    }\n    return true;\n  }\n  if (isDataDescriptor(current) && isDataDescriptor(desc)) {\n    if (current.configurable === false) {\n      if (current.writable === false && desc.writable === true) {\n        return false;\n      }\n      if (current.writable === false) {\n        if ('value' in desc && !sameValue(desc.value, current.value)) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n  if (isAccessorDescriptor(current) && isAccessorDescriptor(desc)) {\n    if (current.configurable === false) {\n      if ('set' in desc && !sameValue(desc.set, current.set)) {\n        return false;\n      }\n      if ('get' in desc && !sameValue(desc.get, current.get)) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\n// ES6 7.3.11 SetIntegrityLevel\n// level is one of \"sealed\" or \"frozen\"\nfunction setIntegrityLevel(target, level) {\n  var ownProps = Object_getOwnPropertyNames(target);\n  var pendingException = undefined;\n  if (level === \"sealed\") {\n    var l = +ownProps.length;\n    var k;\n    for (var i = 0; i < l; i++) {\n      k = String(ownProps[i]);\n      try {\n        Object.defineProperty(target, k, { configurable: false });\n      } catch (e) {\n        if (pendingException === undefined) {\n          pendingException = e;\n        }\n      }\n    }\n  } else {\n    // level === \"frozen\"\n    var l = +ownProps.length;\n    var k;\n    for (var i = 0; i < l; i++) {\n      k = String(ownProps[i]);\n      try {\n        var currentDesc = Object.getOwnPropertyDescriptor(target, k);\n        if (currentDesc !== undefined) {\n          var desc;\n          if (isAccessorDescriptor(currentDesc)) {\n            desc = { configurable: false }\n          } else {\n            desc = { configurable: false, writable: false }\n          }\n          Object.defineProperty(target, k, desc);\n        }        \n      } catch (e) {\n        if (pendingException === undefined) {\n          pendingException = e;\n        }\n      }\n    }\n  }\n  if (pendingException !== undefined) {\n    throw pendingException;\n  }\n  return Reflect.preventExtensions(target);\n}\n\n// ES6 7.3.12 TestIntegrityLevel\n// level is one of \"sealed\" or \"frozen\"\nfunction testIntegrityLevel(target, level) {\n  var isExtensible = Object_isExtensible(target);\n  if (isExtensible) return false;\n  \n  var ownProps = Object_getOwnPropertyNames(target);\n  var pendingException = undefined;\n  var configurable = false;\n  var writable = false;\n  \n  var l = +ownProps.length;\n  var k;\n  var currentDesc;\n  for (var i = 0; i < l; i++) {\n    k = String(ownProps[i]);\n    try {\n      currentDesc = Object.getOwnPropertyDescriptor(target, k);\n      configurable = configurable || currentDesc.configurable;\n      if (isDataDescriptor(currentDesc)) {\n        writable = writable || currentDesc.writable;\n      }\n    } catch (e) {\n      if (pendingException === undefined) {\n        pendingException = e;\n        configurable = true;\n      }\n    }\n  }\n  if (pendingException !== undefined) {\n    throw pendingException;\n  }\n  if (level === \"frozen\" && writable === true) {\n    return false;\n  }\n  if (configurable === true) {\n    return false;\n  }\n  return true;\n}\n\n// ---- The Validator handler wrapper around user handlers ----\n\n/**\n * @param target the object wrapped by this proxy.\n * As long as the proxy is extensible, only non-configurable properties\n * are checked against the target. Once the proxy becomes non-extensible,\n * invariants w.r.t. non-extensibility are also enforced.\n *\n * @param handler the handler of the direct proxy. The object emulated by\n * this handler is validated against the target object of the direct proxy.\n * Any violations that the handler makes against the invariants\n * of the target will cause a TypeError to be thrown.\n *\n * Both target and handler must be proper Objects at initialization time.\n */\nfunction Validator(target, handler) {\n  // for non-revokable proxies, these are const references\n  // for revokable proxies, on revocation:\n  // - this.target is set to null\n  // - this.handler is set to a handler that throws on all traps\n  this.target  = target;\n  this.handler = handler;\n}\n\nValidator.prototype = {\n\n  /**\n   * If getTrap returns undefined, the caller should perform the\n   * default forwarding behavior.\n   * If getTrap returns normally otherwise, the return value\n   * will be a callable trap function. When calling the trap function,\n   * the caller is responsible for binding its |this| to |this.handler|.\n   */\n  getTrap: function(trapName) {\n    var trap = this.handler[trapName];\n    if (trap === undefined) {\n      // the trap was not defined,\n      // perform the default forwarding behavior\n      return undefined;\n    }\n\n    if (typeof trap !== \"function\") {\n      throw new TypeError(trapName + \" trap is not callable: \"+trap);\n    }\n\n    return trap;\n  },\n\n  // === fundamental traps ===\n\n  /**\n   * If name denotes a fixed property, check:\n   *   - whether targetHandler reports it as existent\n   *   - whether the returned descriptor is compatible with the fixed property\n   * If the proxy is non-extensible, check:\n   *   - whether name is not a new property\n   * Additionally, the returned descriptor is normalized and completed.\n   */\n  getOwnPropertyDescriptor: function(name) {\n    \"use strict\";\n\n    var trap = this.getTrap(\"getOwnPropertyDescriptor\");\n    if (trap === undefined) {\n      return Reflect.getOwnPropertyDescriptor(this.target, name);\n    }\n\n    name = String(name);\n    var desc = trap.call(this.handler, this.target, name);\n    desc = normalizeAndCompletePropertyDescriptor(desc);\n\n    var targetDesc = Object.getOwnPropertyDescriptor(this.target, name);\n    var extensible = Object.isExtensible(this.target);\n\n    if (desc === undefined) {\n      if (isSealedDesc(targetDesc)) {\n        throw new TypeError(\"cannot report non-configurable property '\"+name+\n                            \"' as non-existent\");\n      }\n      if (!extensible && targetDesc !== undefined) {\n          // if handler is allowed to return undefined, we cannot guarantee\n          // that it will not return a descriptor for this property later.\n          // Once a property has been reported as non-existent on a non-extensible\n          // object, it should forever be reported as non-existent\n          throw new TypeError(\"cannot report existing own property '\"+name+\n                              \"' as non-existent on a non-extensible object\");\n      }\n      return undefined;\n    }\n\n    // at this point, we know (desc !== undefined), i.e.\n    // targetHandler reports 'name' as an existing property\n\n    // Note: we could collapse the following two if-tests into a single\n    // test. Separating out the cases to improve error reporting.\n\n    if (!extensible) {\n      if (targetDesc === undefined) {\n        throw new TypeError(\"cannot report a new own property '\"+\n                            name + \"' on a non-extensible object\");\n      }\n    }\n\n    if (name !== undefined) {\n      if (!isCompatibleDescriptor(extensible, targetDesc, desc)) {\n        throw new TypeError(\"cannot report incompatible property descriptor \"+\n                            \"for property '\"+name+\"'\");\n      }\n    }\n    \n    if (desc.configurable === false) {\n      if (targetDesc === undefined || targetDesc.configurable === true) {\n        // if the property is configurable or non-existent on the target,\n        // but is reported as a non-configurable property, it may later be\n        // reported as configurable or non-existent, which violates the\n        // invariant that if the property might change or disappear, the\n        // configurable attribute must be true.\n        throw new TypeError(\n          \"cannot report a non-configurable descriptor \" +\n          \"for configurable or non-existent property '\" + name + \"'\");\n      }\n      if ('writable' in desc && desc.writable === false) {\n        if (targetDesc.writable === true) {\n          // if the property is non-configurable, writable on the target,\n          // but is reported as non-configurable, non-writable, it may later\n          // be reported as non-configurable, writable again, which violates\n          // the invariant that a non-configurable, non-writable property\n          // may not change state.\n          throw new TypeError(\n            \"cannot report non-configurable, writable property '\" + name +\n            \"' as non-configurable, non-writable\");\n        }\n      }\n    }\n\n    return desc;\n  },\n\n  /**\n   * In the direct proxies design with refactored prototype climbing,\n   * this trap is deprecated. For proxies-as-prototypes, instead\n   * of calling this trap, the get, set, has or enumerate traps are\n   * called instead.\n   *\n   * In this implementation, we \"abuse\" getPropertyDescriptor to\n   * support trapping the get or set traps for proxies-as-prototypes.\n   * We do this by returning a getter/setter pair that invokes\n   * the corresponding traps.\n   *\n   * While this hack works for inherited property access, it has some\n   * quirks:\n   *\n   * In Firefox, this trap is only called after a prior invocation\n   * of the 'has' trap has returned true. Hence, expect the following\n   * behavior:\n   * <code>\n   * var child = Object.create(Proxy(target, handler));\n   * child[name] // triggers handler.has(target, name)\n   * // if that returns true, triggers handler.get(target, name, child)\n   * </code>\n   *\n   * On v8, the 'in' operator, when applied to an object that inherits\n   * from a proxy, will call getPropertyDescriptor and walk the proto-chain.\n   * That calls the below getPropertyDescriptor trap on the proxy. The\n   * result of the 'in'-operator is then determined by whether this trap\n   * returns undefined or a property descriptor object. That is why\n   * we first explicitly trigger the 'has' trap to determine whether\n   * the property exists.\n   *\n   * This has the side-effect that when enumerating properties on\n   * an object that inherits from a proxy in v8, only properties\n   * for which 'has' returns true are returned:\n   *\n   * <code>\n   * var child = Object.create(Proxy(target, handler));\n   * for (var prop in child) {\n   *   // only enumerates prop if (prop in child) returns true\n   * }\n   * </code>\n   */\n  getPropertyDescriptor: function(name) {\n    var handler = this;\n\n    if (!handler.has(name)) return undefined;\n\n    return {\n      get: function() {\n        return handler.get(this, name);\n      },\n      set: function(val) {\n        if (handler.set(this, name, val)) {\n          return val;\n        } else {\n          throw new TypeError(\"failed assignment to \"+name);\n        }\n      },\n      enumerable: true,\n      configurable: true\n    };\n  },\n\n  /**\n   * If name denotes a fixed property, check for incompatible changes.\n   * If the proxy is non-extensible, check that new properties are rejected.\n   */\n  defineProperty: function(name, desc) {\n    // TODO(tvcutsem): the current tracemonkey implementation of proxies\n    // auto-completes 'desc', which is not correct. 'desc' should be\n    // normalized, but not completed. Consider:\n    // Object.defineProperty(proxy, 'foo', {enumerable:false})\n    // This trap will receive desc =\n    //  {value:undefined,writable:false,enumerable:false,configurable:false}\n    // This will also set all other attributes to their default value,\n    // which is unexpected and different from [[DefineOwnProperty]].\n    // Bug filed: https://bugzilla.mozilla.org/show_bug.cgi?id=601329\n\n    var trap = this.getTrap(\"defineProperty\");\n    if (trap === undefined) {\n      // default forwarding behavior\n      return Reflect.defineProperty(this.target, name, desc);\n    }\n\n    name = String(name);\n    var descObj = normalizePropertyDescriptor(desc);\n    var success = trap.call(this.handler, this.target, name, descObj);\n    success = !!success; // coerce to Boolean\n\n    if (success === true) {\n\n      var targetDesc = Object.getOwnPropertyDescriptor(this.target, name);\n      var extensible = Object.isExtensible(this.target);\n\n      // Note: we could collapse the following two if-tests into a single\n      // test. Separating out the cases to improve error reporting.\n\n      if (!extensible) {\n        if (targetDesc === undefined) {\n          throw new TypeError(\"cannot successfully add a new property '\"+\n                              name + \"' to a non-extensible object\");\n        }\n      }\n\n      if (targetDesc !== undefined) {\n        if (!isCompatibleDescriptor(extensible, targetDesc, desc)) {\n          throw new TypeError(\"cannot define incompatible property \"+\n                              \"descriptor for property '\"+name+\"'\");\n        }\n        if (isDataDescriptor(targetDesc) &&\n            targetDesc.configurable === false &&\n            targetDesc.writable === true) {\n            if (desc.configurable === false && desc.writable === false) {\n              // if the property is non-configurable, writable on the target\n              // but was successfully reported to be updated to\n              // non-configurable, non-writable, it can later be reported\n              // again as non-configurable, writable, which violates\n              // the invariant that non-configurable, non-writable properties\n              // cannot change state\n              throw new TypeError(\n                \"cannot successfully define non-configurable, writable \" +\n                \" property '\" + name + \"' as non-configurable, non-writable\");\n            }\n          }\n      }\n\n      if (desc.configurable === false && !isSealedDesc(targetDesc)) {\n        // if the property is configurable or non-existent on the target,\n        // but is successfully being redefined as a non-configurable property,\n        // it may later be reported as configurable or non-existent, which violates\n        // the invariant that if the property might change or disappear, the\n        // configurable attribute must be true.\n        throw new TypeError(\n          \"cannot successfully define a non-configurable \" +\n          \"descriptor for configurable or non-existent property '\" +\n          name + \"'\");\n      }\n\n    }\n\n    return success;\n  },\n\n  /**\n   * On success, check whether the target object is indeed non-extensible.\n   */\n  preventExtensions: function() {\n    var trap = this.getTrap(\"preventExtensions\");\n    if (trap === undefined) {\n      // default forwarding behavior\n      return Reflect.preventExtensions(this.target);\n    }\n\n    var success = trap.call(this.handler, this.target);\n    success = !!success; // coerce to Boolean\n    if (success) {\n      if (Object_isExtensible(this.target)) {\n        throw new TypeError(\"can't report extensible object as non-extensible: \"+\n                            this.target);\n      }\n    }\n    return success;\n  },\n\n  /**\n   * If name denotes a sealed property, check whether handler rejects.\n   */\n  delete: function(name) {\n    \"use strict\";\n    var trap = this.getTrap(\"deleteProperty\");\n    if (trap === undefined) {\n      // default forwarding behavior\n      return Reflect.deleteProperty(this.target, name);\n    }\n\n    name = String(name);\n    var res = trap.call(this.handler, this.target, name);\n    res = !!res; // coerce to Boolean\n\n    var targetDesc;\n    if (res === true) {\n      targetDesc = Object.getOwnPropertyDescriptor(this.target, name);\n      if (targetDesc !== undefined && targetDesc.configurable === false) {\n        throw new TypeError(\"property '\" + name + \"' is non-configurable \"+\n                            \"and can't be deleted\");\n      }\n      if (targetDesc !== undefined && !Object_isExtensible(this.target)) {\n        // if the property still exists on a non-extensible target but\n        // is reported as successfully deleted, it may later be reported\n        // as present, which violates the invariant that an own property,\n        // deleted from a non-extensible object cannot reappear.\n        throw new TypeError(\n          \"cannot successfully delete existing property '\" + name +\n          \"' on a non-extensible object\");\n      }\n    }\n\n    return res;\n  },\n\n  /**\n   * The getOwnPropertyNames trap was replaced by the ownKeys trap,\n   * which now also returns an array (of strings or symbols) and\n   * which performs the same rigorous invariant checks as getOwnPropertyNames\n   *\n   * See issue #48 on how this trap can still get invoked by external libs\n   * that don't use the patched Object.getOwnPropertyNames function.\n   */\n  getOwnPropertyNames: function() {\n    // Note: removed deprecation warning to avoid dependency on 'console'\n    // (and on node, should anyway use util.deprecate). Deprecation warnings\n    // can also be annoying when they are outside of the user's control, e.g.\n    // when an external library calls unpatched Object.getOwnPropertyNames.\n    // Since there is a clean fallback to `ownKeys`, the fact that the\n    // deprecated method is still called is mostly harmless anyway.\n    // See also issues #65 and #66.\n    // console.warn(\"getOwnPropertyNames trap is deprecated. Use ownKeys instead\");\n    return this.ownKeys();\n  },\n\n  /**\n   * Checks whether the trap result does not contain any new properties\n   * if the proxy is non-extensible.\n   *\n   * Any own non-configurable properties of the target that are not included\n   * in the trap result give rise to a TypeError. As such, we check whether the\n   * returned result contains at least all sealed properties of the target\n   * object.\n   *\n   * Additionally, the trap result is normalized.\n   * Instead of returning the trap result directly:\n   *  - create and return a fresh Array,\n   *  - of which each element is coerced to a String\n   *\n   * This trap is called a.o. by Reflect.ownKeys, Object.getOwnPropertyNames\n   * and Object.keys (the latter filters out only the enumerable own properties).\n   */\n  ownKeys: function() {\n    var trap = this.getTrap(\"ownKeys\");\n    if (trap === undefined) {\n      // default forwarding behavior\n      return Reflect.ownKeys(this.target);\n    }\n\n    var trapResult = trap.call(this.handler, this.target);\n\n    // propNames is used as a set of strings\n    var propNames = Object.create(null);\n    var numProps = +trapResult.length;\n    var result = new Array(numProps);\n\n    for (var i = 0; i < numProps; i++) {\n      var s = String(trapResult[i]);\n      if (!Object.isExtensible(this.target) && !isFixed(s, this.target)) {\n        // non-extensible proxies don't tolerate new own property names\n        throw new TypeError(\"ownKeys trap cannot list a new \"+\n                            \"property '\"+s+\"' on a non-extensible object\");\n      }\n\n      propNames[s] = true;\n      result[i] = s;\n    }\n\n    var ownProps = Object_getOwnPropertyNames(this.target);\n    var target = this.target;\n    ownProps.forEach(function (ownProp) {\n      if (!propNames[ownProp]) {\n        if (isSealed(ownProp, target)) {\n          throw new TypeError(\"ownKeys trap failed to include \"+\n                              \"non-configurable property '\"+ownProp+\"'\");\n        }\n        if (!Object.isExtensible(target) &&\n            isFixed(ownProp, target)) {\n            // if handler is allowed to report ownProp as non-existent,\n            // we cannot guarantee that it will never later report it as\n            // existent. Once a property has been reported as non-existent\n            // on a non-extensible object, it should forever be reported as\n            // non-existent\n            throw new TypeError(\"ownKeys trap cannot report existing own property '\"+\n                                ownProp+\"' as non-existent on a non-extensible object\");\n        }\n      }\n    });\n\n    return result;\n  },\n\n  /**\n   * Checks whether the trap result is consistent with the state of the\n   * wrapped target.\n   */\n  isExtensible: function() {\n    var trap = this.getTrap(\"isExtensible\");\n    if (trap === undefined) {\n      // default forwarding behavior\n      return Reflect.isExtensible(this.target);\n    }\n\n    var result = trap.call(this.handler, this.target);\n    result = !!result; // coerce to Boolean\n    var state = Object_isExtensible(this.target);\n    if (result !== state) {\n      if (result) {\n        throw new TypeError(\"cannot report non-extensible object as extensible: \"+\n                             this.target);\n      } else {\n        throw new TypeError(\"cannot report extensible object as non-extensible: \"+\n                             this.target);\n      }\n    }\n    return state;\n  },\n\n  /**\n   * Check whether the trap result corresponds to the target's [[Prototype]]\n   */\n  getPrototypeOf: function() {\n    var trap = this.getTrap(\"getPrototypeOf\");\n    if (trap === undefined) {\n      // default forwarding behavior\n      return Reflect.getPrototypeOf(this.target);\n    }\n\n    var allegedProto = trap.call(this.handler, this.target);\n\n    if (!Object_isExtensible(this.target)) {\n      var actualProto = Object_getPrototypeOf(this.target);\n      if (!sameValue(allegedProto, actualProto)) {\n        throw new TypeError(\"prototype value does not match: \" + this.target);\n      }\n    }\n\n    return allegedProto;\n  },\n\n  /**\n   * If target is non-extensible and setPrototypeOf trap returns true,\n   * check whether the trap result corresponds to the target's [[Prototype]]\n   */\n  setPrototypeOf: function(newProto) {\n    var trap = this.getTrap(\"setPrototypeOf\");\n    if (trap === undefined) {\n      // default forwarding behavior\n      return Reflect.setPrototypeOf(this.target, newProto);\n    }\n\n    var success = trap.call(this.handler, this.target, newProto);\n\n    success = !!success;\n    if (success && !Object_isExtensible(this.target)) {\n      var actualProto = Object_getPrototypeOf(this.target);\n      if (!sameValue(newProto, actualProto)) {\n        throw new TypeError(\"prototype value does not match: \" + this.target);\n      }\n    }\n\n    return success;\n  },\n\n  /**\n   * In the direct proxies design with refactored prototype climbing,\n   * this trap is deprecated. For proxies-as-prototypes, for-in will\n   * call the enumerate() trap. If that trap is not defined, the\n   * operation is forwarded to the target, no more fallback on this\n   * fundamental trap.\n   */\n  getPropertyNames: function() {\n    throw new TypeError(\"getPropertyNames trap is deprecated\");\n  },\n\n  // === derived traps ===\n\n  /**\n   * If name denotes a fixed property, check whether the trap returns true.\n   */\n  has: function(name) {\n    var trap = this.getTrap(\"has\");\n    if (trap === undefined) {\n      // default forwarding behavior\n      return Reflect.has(this.target, name);\n    }\n\n    name = String(name);\n    var res = trap.call(this.handler, this.target, name);\n    res = !!res; // coerce to Boolean\n\n    if (res === false) {\n      if (isSealed(name, this.target)) {\n        throw new TypeError(\"cannot report existing non-configurable own \"+\n                            \"property '\"+ name + \"' as a non-existent \"+\n                            \"property\");\n      }\n      if (!Object.isExtensible(this.target) &&\n          isFixed(name, this.target)) {\n          // if handler is allowed to return false, we cannot guarantee\n          // that it will not return true for this property later.\n          // Once a property has been reported as non-existent on a non-extensible\n          // object, it should forever be reported as non-existent\n          throw new TypeError(\"cannot report existing own property '\"+name+\n                              \"' as non-existent on a non-extensible object\");\n      }\n    }\n\n    // if res === true, we don't need to check for extensibility\n    // even for a non-extensible proxy that has no own name property,\n    // the property may have been inherited\n\n    return res;\n  },\n\n  /**\n   * If name denotes a fixed non-configurable, non-writable data property,\n   * check its return value against the previously asserted value of the\n   * fixed property.\n   */\n  get: function(receiver, name) {\n\n    // experimental support for invoke() trap on platforms that\n    // support __noSuchMethod__\n    /*\n    if (name === '__noSuchMethod__') {\n      var handler = this;\n      return function(name, args) {\n        return handler.invoke(receiver, name, args);\n      }\n    }\n    */\n\n    var trap = this.getTrap(\"get\");\n    if (trap === undefined) {\n      // default forwarding behavior\n      return Reflect.get(this.target, name, receiver);\n    }\n\n    name = String(name);\n    var res = trap.call(this.handler, this.target, name, receiver);\n\n    var fixedDesc = Object.getOwnPropertyDescriptor(this.target, name);\n    // check consistency of the returned value\n    if (fixedDesc !== undefined) { // getting an existing property\n      if (isDataDescriptor(fixedDesc) &&\n          fixedDesc.configurable === false &&\n          fixedDesc.writable === false) { // own frozen data property\n        if (!sameValue(res, fixedDesc.value)) {\n          throw new TypeError(\"cannot report inconsistent value for \"+\n                              \"non-writable, non-configurable property '\"+\n                              name+\"'\");\n        }\n      } else { // it's an accessor property\n        if (isAccessorDescriptor(fixedDesc) &&\n            fixedDesc.configurable === false &&\n            fixedDesc.get === undefined) {\n          if (res !== undefined) {\n            throw new TypeError(\"must report undefined for non-configurable \"+\n                                \"accessor property '\"+name+\"' without getter\");\n          }\n        }\n      }\n    }\n\n    return res;\n  },\n\n  /**\n   * If name denotes a fixed non-configurable, non-writable data property,\n   * check that the trap rejects the assignment.\n   */\n  set: function(receiver, name, val) {\n    var trap = this.getTrap(\"set\");\n    if (trap === undefined) {\n      // default forwarding behavior\n      return Reflect.set(this.target, name, val, receiver);\n    }\n\n    name = String(name);\n    var res = trap.call(this.handler, this.target, name, val, receiver);\n    res = !!res; // coerce to Boolean\n\n    // if success is reported, check whether property is truly assignable\n    if (res === true) {\n      var fixedDesc = Object.getOwnPropertyDescriptor(this.target, name);\n      if (fixedDesc !== undefined) { // setting an existing property\n        if (isDataDescriptor(fixedDesc) &&\n            fixedDesc.configurable === false &&\n            fixedDesc.writable === false) {\n          if (!sameValue(val, fixedDesc.value)) {\n            throw new TypeError(\"cannot successfully assign to a \"+\n                                \"non-writable, non-configurable property '\"+\n                                name+\"'\");\n          }\n        } else {\n          if (isAccessorDescriptor(fixedDesc) &&\n              fixedDesc.configurable === false && // non-configurable\n              fixedDesc.set === undefined) {      // accessor with undefined setter\n            throw new TypeError(\"setting a property '\"+name+\"' that has \"+\n                                \" only a getter\");\n          }\n        }\n      }\n    }\n\n    return res;\n  },\n\n  /**\n   * Any own enumerable non-configurable properties of the target that are not\n   * included in the trap result give rise to a TypeError. As such, we check\n   * whether the returned result contains at least all sealed enumerable properties\n   * of the target object.\n   *\n   * The trap should return an iterator.\n   *\n   * However, as implementations of pre-direct proxies still expect enumerate\n   * to return an array of strings, we convert the iterator into an array.\n   */\n  enumerate: function() {\n    var trap = this.getTrap(\"enumerate\");\n    if (trap === undefined) {\n      // default forwarding behavior\n      var trapResult = Reflect.enumerate(this.target);\n      var result = [];\n      var nxt = trapResult.next();\n      while (!nxt.done) {\n        result.push(String(nxt.value));\n        nxt = trapResult.next();\n      }\n      return result;\n    }\n\n    var trapResult = trap.call(this.handler, this.target);\n    \n    if (trapResult === null ||\n        trapResult === undefined ||\n        trapResult.next === undefined) {\n      throw new TypeError(\"enumerate trap should return an iterator, got: \"+\n                          trapResult);    \n    }\n    \n    // propNames is used as a set of strings\n    var propNames = Object.create(null);\n    \n    // var numProps = +trapResult.length;\n    var result = []; // new Array(numProps);\n    \n    // trapResult is supposed to be an iterator\n    // drain iterator to array as current implementations still expect\n    // enumerate to return an array of strings\n    var nxt = trapResult.next();\n    \n    while (!nxt.done) {\n      var s = String(nxt.value);\n      if (propNames[s]) {\n        throw new TypeError(\"enumerate trap cannot list a \"+\n                            \"duplicate property '\"+s+\"'\");\n      }\n      propNames[s] = true;\n      result.push(s);\n      nxt = trapResult.next();\n    }\n    \n    /*for (var i = 0; i < numProps; i++) {\n      var s = String(trapResult[i]);\n      if (propNames[s]) {\n        throw new TypeError(\"enumerate trap cannot list a \"+\n                            \"duplicate property '\"+s+\"'\");\n      }\n\n      propNames[s] = true;\n      result[i] = s;\n    } */\n\n    var ownEnumerableProps = Object.keys(this.target);\n    var target = this.target;\n    ownEnumerableProps.forEach(function (ownEnumerableProp) {\n      if (!propNames[ownEnumerableProp]) {\n        if (isSealed(ownEnumerableProp, target)) {\n          throw new TypeError(\"enumerate trap failed to include \"+\n                              \"non-configurable enumerable property '\"+\n                              ownEnumerableProp+\"'\");\n        }\n        if (!Object.isExtensible(target) &&\n            isFixed(ownEnumerableProp, target)) {\n            // if handler is allowed not to report ownEnumerableProp as an own\n            // property, we cannot guarantee that it will never report it as\n            // an own property later. Once a property has been reported as\n            // non-existent on a non-extensible object, it should forever be\n            // reported as non-existent\n            throw new TypeError(\"cannot report existing own property '\"+\n                                ownEnumerableProp+\"' as non-existent on a \"+\n                                \"non-extensible object\");\n        }\n      }\n    });\n\n    return result;\n  },\n\n  /**\n   * The iterate trap is deprecated by the enumerate trap.\n   */\n  iterate: Validator.prototype.enumerate,\n\n  /**\n   * Any own non-configurable properties of the target that are not included\n   * in the trap result give rise to a TypeError. As such, we check whether the\n   * returned result contains at least all sealed properties of the target\n   * object.\n   *\n   * The trap result is normalized.\n   * The trap result is not returned directly. Instead:\n   *  - create and return a fresh Array,\n   *  - of which each element is coerced to String,\n   *  - which does not contain duplicates\n   *\n   * FIXME: keys trap is deprecated\n   */\n  /*\n  keys: function() {\n    var trap = this.getTrap(\"keys\");\n    if (trap === undefined) {\n      // default forwarding behavior\n      return Reflect.keys(this.target);\n    }\n\n    var trapResult = trap.call(this.handler, this.target);\n\n    // propNames is used as a set of strings\n    var propNames = Object.create(null);\n    var numProps = +trapResult.length;\n    var result = new Array(numProps);\n\n    for (var i = 0; i < numProps; i++) {\n     var s = String(trapResult[i]);\n     if (propNames[s]) {\n       throw new TypeError(\"keys trap cannot list a \"+\n                           \"duplicate property '\"+s+\"'\");\n     }\n     if (!Object.isExtensible(this.target) && !isFixed(s, this.target)) {\n       // non-extensible proxies don't tolerate new own property names\n       throw new TypeError(\"keys trap cannot list a new \"+\n                           \"property '\"+s+\"' on a non-extensible object\");\n     }\n\n     propNames[s] = true;\n     result[i] = s;\n    }\n\n    var ownEnumerableProps = Object.keys(this.target);\n    var target = this.target;\n    ownEnumerableProps.forEach(function (ownEnumerableProp) {\n      if (!propNames[ownEnumerableProp]) {\n        if (isSealed(ownEnumerableProp, target)) {\n          throw new TypeError(\"keys trap failed to include \"+\n                              \"non-configurable enumerable property '\"+\n                              ownEnumerableProp+\"'\");\n        }\n        if (!Object.isExtensible(target) &&\n            isFixed(ownEnumerableProp, target)) {\n            // if handler is allowed not to report ownEnumerableProp as an own\n            // property, we cannot guarantee that it will never report it as\n            // an own property later. Once a property has been reported as\n            // non-existent on a non-extensible object, it should forever be\n            // reported as non-existent\n            throw new TypeError(\"cannot report existing own property '\"+\n                                ownEnumerableProp+\"' as non-existent on a \"+\n                                \"non-extensible object\");\n        }\n      }\n    });\n\n    return result;\n  },\n  */\n  \n  /**\n   * New trap that reifies [[Call]].\n   * If the target is a function, then a call to\n   *   proxy(...args)\n   * Triggers this trap\n   */\n  apply: function(target, thisBinding, args) {\n    var trap = this.getTrap(\"apply\");\n    if (trap === undefined) {\n      return Reflect.apply(target, thisBinding, args);\n    }\n\n    if (typeof this.target === \"function\") {\n      return trap.call(this.handler, target, thisBinding, args);\n    } else {\n      throw new TypeError(\"apply: \"+ target + \" is not a function\");\n    }\n  },\n\n  /**\n   * New trap that reifies [[Construct]].\n   * If the target is a function, then a call to\n   *   new proxy(...args)\n   * Triggers this trap\n   */\n  construct: function(target, args, newTarget) {\n    var trap = this.getTrap(\"construct\");\n    if (trap === undefined) {\n      return Reflect.construct(target, args, newTarget);\n    }\n\n    if (typeof target !== \"function\") {\n      throw new TypeError(\"new: \"+ target + \" is not a function\");\n    }\n\n    if (newTarget === undefined) {\n      newTarget = target;\n    } else {\n      if (typeof newTarget !== \"function\") {\n        throw new TypeError(\"new: \"+ newTarget + \" is not a function\");\n      }      \n    }\n    return trap.call(this.handler, target, args, newTarget);\n  }\n};\n\n// ---- end of the Validator handler wrapper handler ----\n\n// In what follows, a 'direct proxy' is a proxy\n// whose handler is a Validator. Such proxies can be made non-extensible,\n// sealed or frozen without losing the ability to trap.\n\n// maps direct proxies to their Validator handlers\nvar directProxies = new WeakMap();\n\n// patch Object.{preventExtensions,seal,freeze} so that\n// they recognize fixable proxies and act accordingly\nObject.preventExtensions = function(subject) {\n  var vhandler = directProxies.get(subject);\n  if (vhandler !== undefined) {\n    if (vhandler.preventExtensions()) {\n      return subject;\n    } else {\n      throw new TypeError(\"preventExtensions on \"+subject+\" rejected\");\n    }\n  } else {\n    return prim_preventExtensions(subject);\n  }\n};\nObject.seal = function(subject) {\n  setIntegrityLevel(subject, \"sealed\");\n  return subject;\n};\nObject.freeze = function(subject) {\n  setIntegrityLevel(subject, \"frozen\");\n  return subject;\n};\nObject.isExtensible = Object_isExtensible = function(subject) {\n  var vHandler = directProxies.get(subject);\n  if (vHandler !== undefined) {\n    return vHandler.isExtensible();\n  } else {\n    return prim_isExtensible(subject);\n  }\n};\nObject.isSealed = Object_isSealed = function(subject) {\n  return testIntegrityLevel(subject, \"sealed\");\n};\nObject.isFrozen = Object_isFrozen = function(subject) {\n  return testIntegrityLevel(subject, \"frozen\");\n};\nObject.getPrototypeOf = Object_getPrototypeOf = function(subject) {\n  var vHandler = directProxies.get(subject);\n  if (vHandler !== undefined) {\n    return vHandler.getPrototypeOf();\n  } else {\n    return prim_getPrototypeOf(subject);\n  }\n};\n\n// patch Object.getOwnPropertyDescriptor to directly call\n// the Validator.prototype.getOwnPropertyDescriptor trap\n// This is to circumvent an assertion in the built-in Proxy\n// trapping mechanism of v8, which disallows that trap to\n// return non-configurable property descriptors (as per the\n// old Proxy design)\nObject.getOwnPropertyDescriptor = function(subject, name) {\n  var vhandler = directProxies.get(subject);\n  if (vhandler !== undefined) {\n    return vhandler.getOwnPropertyDescriptor(name);\n  } else {\n    return prim_getOwnPropertyDescriptor(subject, name);\n  }\n};\n\n// patch Object.defineProperty to directly call\n// the Validator.prototype.defineProperty trap\n// This is to circumvent two issues with the built-in\n// trap mechanism:\n// 1) the current tracemonkey implementation of proxies\n// auto-completes 'desc', which is not correct. 'desc' should be\n// normalized, but not completed. Consider:\n// Object.defineProperty(proxy, 'foo', {enumerable:false})\n// This trap will receive desc =\n//  {value:undefined,writable:false,enumerable:false,configurable:false}\n// This will also set all other attributes to their default value,\n// which is unexpected and different from [[DefineOwnProperty]].\n// Bug filed: https://bugzilla.mozilla.org/show_bug.cgi?id=601329\n// 2) the current spidermonkey implementation does not\n// throw an exception when this trap returns 'false', but instead silently\n// ignores the operation (this is regardless of strict-mode)\n// 2a) v8 does throw an exception for this case, but includes the rather\n//     unhelpful error message:\n// 'Proxy handler #<Object> returned false from 'defineProperty' trap'\nObject.defineProperty = function(subject, name, desc) {\n  var vhandler = directProxies.get(subject);\n  if (vhandler !== undefined) {\n    var normalizedDesc = normalizePropertyDescriptor(desc);\n    var success = vhandler.defineProperty(name, normalizedDesc);\n    if (success === false) {\n      throw new TypeError(\"can't redefine property '\"+name+\"'\");\n    }\n    return subject;\n  } else {\n    return prim_defineProperty(subject, name, desc);\n  }\n};\n\nObject.defineProperties = function(subject, descs) {\n  var vhandler = directProxies.get(subject);\n  if (vhandler !== undefined) {\n    var names = Object.keys(descs);\n    for (var i = 0; i < names.length; i++) {\n      var name = names[i];\n      var normalizedDesc = normalizePropertyDescriptor(descs[name]);\n      var success = vhandler.defineProperty(name, normalizedDesc);\n      if (success === false) {\n        throw new TypeError(\"can't redefine property '\"+name+\"'\");\n      }\n    }\n    return subject;\n  } else {\n    return prim_defineProperties(subject, descs);\n  }\n};\n\nObject.keys = function(subject) {\n  var vHandler = directProxies.get(subject);\n  if (vHandler !== undefined) {\n    var ownKeys = vHandler.ownKeys();\n    var result = [];\n    for (var i = 0; i < ownKeys.length; i++) {\n      var k = String(ownKeys[i]);\n      var desc = Object.getOwnPropertyDescriptor(subject, k);\n      if (desc !== undefined && desc.enumerable === true) {\n        result.push(k);\n      }\n    }\n    return result;\n  } else {\n    return prim_keys(subject);\n  }\n}\n\nObject.getOwnPropertyNames = Object_getOwnPropertyNames = function(subject) {\n  var vHandler = directProxies.get(subject);\n  if (vHandler !== undefined) {\n    return vHandler.ownKeys();\n  } else {\n    return prim_getOwnPropertyNames(subject);\n  }\n}\n\n// fixes issue #71 (Calling Object.getOwnPropertySymbols() on a Proxy\n// throws an error)\nif (prim_getOwnPropertySymbols !== undefined) {\n  Object.getOwnPropertySymbols = function(subject) {\n    var vHandler = directProxies.get(subject);\n    if (vHandler !== undefined) {\n      // as this shim does not support symbols, a Proxy never advertises\n      // any symbol-valued own properties\n      return [];\n    } else {\n      return prim_getOwnPropertySymbols(subject);\n    }\n  };\n}\n\n// fixes issue #72 ('Illegal access' error when using Object.assign)\n// Object.assign polyfill based on a polyfill posted on MDN: \n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/\\\n//  Global_Objects/Object/assign\n// Note that this polyfill does not support Symbols, but this Proxy Shim\n// does not support Symbols anyway.\nif (prim_assign !== undefined) {\n  Object.assign = function (target) {\n    \n    // check if any argument is a proxy object\n    var noProxies = true;\n    for (var i = 0; i < arguments.length; i++) {\n      var vHandler = directProxies.get(arguments[i]);\n      if (vHandler !== undefined) {\n        noProxies = false;\n        break;\n      }\n    }\n    if (noProxies) {\n      // not a single argument is a proxy, perform built-in algorithm\n      return prim_assign.apply(Object, arguments);\n    }\n    \n    // there is at least one proxy argument, use the polyfill\n    \n    if (target === undefined || target === null) {\n      throw new TypeError('Cannot convert undefined or null to object');\n    }\n\n    var output = Object(target);\n    for (var index = 1; index < arguments.length; index++) {\n      var source = arguments[index];\n      if (source !== undefined && source !== null) {\n        for (var nextKey in source) {\n          if (source.hasOwnProperty(nextKey)) {\n            output[nextKey] = source[nextKey];\n          }\n        }\n      }\n    }\n    return output;\n  };\n}\n\n// returns whether an argument is a reference to an object,\n// which is legal as a WeakMap key.\nfunction isObject(arg) {\n  var type = typeof arg;\n  return (type === 'object' && arg !== null) || (type === 'function');\n};\n\n// a wrapper for WeakMap.get which returns the undefined value\n// for keys that are not objects (in which case the underlying\n// WeakMap would have thrown a TypeError).\nfunction safeWeakMapGet(map, key) {\n  return isObject(key) ? map.get(key) : undefined;\n};\n\n// returns a new function of zero arguments that recursively\n// unwraps any proxies specified as the |this|-value.\n// The primitive is assumed to be a zero-argument method\n// that uses its |this|-binding.\nfunction makeUnwrapping0ArgMethod(primitive) {\n  return function builtin() {\n    var vHandler = safeWeakMapGet(directProxies, this);\n    if (vHandler !== undefined) {\n      return builtin.call(vHandler.target);\n    } else {\n      return primitive.call(this);\n    }\n  }\n};\n\n// returns a new function of 1 arguments that recursively\n// unwraps any proxies specified as the |this|-value.\n// The primitive is assumed to be a 1-argument method\n// that uses its |this|-binding.\nfunction makeUnwrapping1ArgMethod(primitive) {\n  return function builtin(arg) {\n    var vHandler = safeWeakMapGet(directProxies, this);\n    if (vHandler !== undefined) {\n      return builtin.call(vHandler.target, arg);\n    } else {\n      return primitive.call(this, arg);\n    }\n  }\n};\n\nObject.prototype.valueOf =\n  makeUnwrapping0ArgMethod(Object.prototype.valueOf);\nObject.prototype.toString =\n  makeUnwrapping0ArgMethod(Object.prototype.toString);\nFunction.prototype.toString =\n  makeUnwrapping0ArgMethod(Function.prototype.toString);\nDate.prototype.toString =\n  makeUnwrapping0ArgMethod(Date.prototype.toString);\n\nObject.prototype.isPrototypeOf = function builtin(arg) {\n  // bugfix thanks to Bill Mark:\n  // built-in isPrototypeOf does not unwrap proxies used\n  // as arguments. So, we implement the builtin ourselves,\n  // based on the ECMAScript 6 spec. Our encoding will\n  // make sure that if a proxy is used as an argument,\n  // its getPrototypeOf trap will be called.\n  while (true) {\n    var vHandler2 = safeWeakMapGet(directProxies, arg);\n    if (vHandler2 !== undefined) {\n      arg = vHandler2.getPrototypeOf();\n      if (arg === null) {\n        return false;\n      } else if (sameValue(arg, this)) {\n        return true;\n      }\n    } else {\n      return prim_isPrototypeOf.call(this, arg);\n    }\n  }\n};\n\nArray.isArray = function(subject) {\n  var vHandler = safeWeakMapGet(directProxies, subject);\n  if (vHandler !== undefined) {\n    return Array.isArray(vHandler.target);\n  } else {\n    return prim_isArray(subject);\n  }\n};\n\nfunction isProxyArray(arg) {\n  var vHandler = safeWeakMapGet(directProxies, arg);\n  if (vHandler !== undefined) {\n    return Array.isArray(vHandler.target);\n  }\n  return false;\n}\n\n// Array.prototype.concat internally tests whether one of its\n// arguments is an Array, by checking whether [[Class]] == \"Array\"\n// As such, it will fail to recognize proxies-for-arrays as arrays.\n// We patch Array.prototype.concat so that it \"unwraps\" proxies-for-arrays\n// by making a copy. This will trigger the exact same sequence of\n// traps on the proxy-for-array as if we would not have unwrapped it.\n// See <https://github.com/tvcutsem/harmony-reflect/issues/19> for more.\nArray.prototype.concat = function(/*...args*/) {\n  var length;\n  for (var i = 0; i < arguments.length; i++) {\n    if (isProxyArray(arguments[i])) {\n      length = arguments[i].length;\n      arguments[i] = Array.prototype.slice.call(arguments[i], 0, length);\n    }\n  }\n  return prim_concat.apply(this, arguments);\n};\n\n// setPrototypeOf support on platforms that support __proto__\n\nvar prim_setPrototypeOf = Object.setPrototypeOf;\n\n// patch and extract original __proto__ setter\nvar __proto__setter = (function() {\n  var protoDesc = prim_getOwnPropertyDescriptor(Object.prototype,'__proto__');\n  if (protoDesc === undefined ||\n      typeof protoDesc.set !== \"function\") {\n    return function() {\n      throw new TypeError(\"setPrototypeOf not supported on this platform\");\n    }\n  }\n\n  // see if we can actually mutate a prototype with the generic setter\n  // (e.g. Chrome v28 doesn't allow setting __proto__ via the generic setter)\n  try {\n    protoDesc.set.call({},{});\n  } catch (e) {\n    return function() {\n      throw new TypeError(\"setPrototypeOf not supported on this platform\");\n    }\n  }\n\n  prim_defineProperty(Object.prototype, '__proto__', {\n    set: function(newProto) {\n      return Object.setPrototypeOf(this, Object(newProto));\n    }\n  });\n\n  return protoDesc.set;\n}());\n\nObject.setPrototypeOf = function(target, newProto) {\n  var handler = directProxies.get(target);\n  if (handler !== undefined) {\n    if (handler.setPrototypeOf(newProto)) {\n      return target;\n    } else {\n      throw new TypeError(\"proxy rejected prototype mutation\");\n    }\n  } else {\n    if (!Object_isExtensible(target)) {\n      throw new TypeError(\"can't set prototype on non-extensible object: \" +\n                          target);\n    }\n    if (prim_setPrototypeOf)\n      return prim_setPrototypeOf(target, newProto);\n\n    if (Object(newProto) !== newProto || newProto === null) {\n      throw new TypeError(\"Object prototype may only be an Object or null: \" +\n                         newProto);\n      // throw new TypeError(\"prototype must be an object or null\")\n    }\n    __proto__setter.call(target, newProto);\n    return target;\n  }\n}\n\nObject.prototype.hasOwnProperty = function(name) {\n  var handler = safeWeakMapGet(directProxies, this);\n  if (handler !== undefined) {\n    var desc = handler.getOwnPropertyDescriptor(name);\n    return desc !== undefined;\n  } else {\n    return prim_hasOwnProperty.call(this, name);\n  }\n}\n\n// ============= Reflection module =============\n// see http://wiki.ecmascript.org/doku.php?id=harmony:reflect_api\n\nvar Reflect = global.Reflect = {\n  getOwnPropertyDescriptor: function(target, name) {\n    return Object.getOwnPropertyDescriptor(target, name);\n  },\n  defineProperty: function(target, name, desc) {\n\n    // if target is a proxy, invoke its \"defineProperty\" trap\n    var handler = directProxies.get(target);\n    if (handler !== undefined) {\n      return handler.defineProperty(target, name, desc);\n    }\n\n    // Implementation transliterated from [[DefineOwnProperty]]\n    // see ES5.1 section 8.12.9\n    // this is the _exact same algorithm_ as the isCompatibleDescriptor\n    // algorithm defined above, except that at every place it\n    // returns true, this algorithm actually does define the property.\n    var current = Object.getOwnPropertyDescriptor(target, name);\n    var extensible = Object.isExtensible(target);\n    if (current === undefined && extensible === false) {\n      return false;\n    }\n    if (current === undefined && extensible === true) {\n      Object.defineProperty(target, name, desc); // should never fail\n      return true;\n    }\n    if (isEmptyDescriptor(desc)) {\n      return true;\n    }\n    if (isEquivalentDescriptor(current, desc)) {\n      return true;\n    }\n    if (current.configurable === false) {\n      if (desc.configurable === true) {\n        return false;\n      }\n      if ('enumerable' in desc && desc.enumerable !== current.enumerable) {\n        return false;\n      }\n    }\n    if (isGenericDescriptor(desc)) {\n      // no further validation necessary\n    } else if (isDataDescriptor(current) !== isDataDescriptor(desc)) {\n      if (current.configurable === false) {\n        return false;\n      }\n    } else if (isDataDescriptor(current) && isDataDescriptor(desc)) {\n      if (current.configurable === false) {\n        if (current.writable === false && desc.writable === true) {\n          return false;\n        }\n        if (current.writable === false) {\n          if ('value' in desc && !sameValue(desc.value, current.value)) {\n            return false;\n          }\n        }\n      }\n    } else if (isAccessorDescriptor(current) && isAccessorDescriptor(desc)) {\n      if (current.configurable === false) {\n        if ('set' in desc && !sameValue(desc.set, current.set)) {\n          return false;\n        }\n        if ('get' in desc && !sameValue(desc.get, current.get)) {\n          return false;\n        }\n      }\n    }\n    Object.defineProperty(target, name, desc); // should never fail\n    return true;\n  },\n  deleteProperty: function(target, name) {\n    var handler = directProxies.get(target);\n    if (handler !== undefined) {\n      return handler.delete(name);\n    }\n    \n    var desc = Object.getOwnPropertyDescriptor(target, name);\n    if (desc === undefined) {\n      return true;\n    }\n    if (desc.configurable === true) {\n      delete target[name];\n      return true;\n    }\n    return false;    \n  },\n  getPrototypeOf: function(target) {\n    return Object.getPrototypeOf(target);\n  },\n  setPrototypeOf: function(target, newProto) {\n    \n    var handler = directProxies.get(target);\n    if (handler !== undefined) {\n      return handler.setPrototypeOf(newProto);\n    }\n    \n    if (Object(newProto) !== newProto || newProto === null) {\n      throw new TypeError(\"Object prototype may only be an Object or null: \" +\n                         newProto);\n    }\n    \n    if (!Object_isExtensible(target)) {\n      return false;\n    }\n    \n    var current = Object.getPrototypeOf(target);\n    if (sameValue(current, newProto)) {\n      return true;\n    }\n    \n    if (prim_setPrototypeOf) {\n      try {\n        prim_setPrototypeOf(target, newProto);\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }\n\n    __proto__setter.call(target, newProto);\n    return true;\n  },\n  preventExtensions: function(target) {\n    var handler = directProxies.get(target);\n    if (handler !== undefined) {\n      return handler.preventExtensions();\n    }\n    prim_preventExtensions(target);\n    return true;\n  },\n  isExtensible: function(target) {\n    return Object.isExtensible(target);\n  },\n  has: function(target, name) {\n    return name in target;\n  },\n  get: function(target, name, receiver) {\n    receiver = receiver || target;\n\n    // if target is a proxy, invoke its \"get\" trap\n    var handler = directProxies.get(target);\n    if (handler !== undefined) {\n      return handler.get(receiver, name);\n    }\n\n    var desc = Object.getOwnPropertyDescriptor(target, name);\n    if (desc === undefined) {\n      var proto = Object.getPrototypeOf(target);\n      if (proto === null) {\n        return undefined;\n      }\n      return Reflect.get(proto, name, receiver);\n    }\n    if (isDataDescriptor(desc)) {\n      return desc.value;\n    }\n    var getter = desc.get;\n    if (getter === undefined) {\n      return undefined;\n    }\n    return desc.get.call(receiver);\n  },\n  // Reflect.set implementation based on latest version of [[SetP]] at\n  // http://wiki.ecmascript.org/doku.php?id=harmony:proto_climbing_refactoring\n  set: function(target, name, value, receiver) {\n    receiver = receiver || target;\n\n    // if target is a proxy, invoke its \"set\" trap\n    var handler = directProxies.get(target);\n    if (handler !== undefined) {\n      return handler.set(receiver, name, value);\n    }\n\n    // first, check whether target has a non-writable property\n    // shadowing name on receiver\n    var ownDesc = Object.getOwnPropertyDescriptor(target, name);\n\n    if (ownDesc === undefined) {\n      // name is not defined in target, search target's prototype\n      var proto = Object.getPrototypeOf(target);\n\n      if (proto !== null) {\n        // continue the search in target's prototype\n        return Reflect.set(proto, name, value, receiver);\n      }\n\n      // Rev16 change. Cf. https://bugs.ecmascript.org/show_bug.cgi?id=1549\n      // target was the last prototype, now we know that 'name' is not shadowed\n      // by an existing (accessor or data) property, so we can add the property\n      // to the initial receiver object\n      // (this branch will intentionally fall through to the code below)\n      ownDesc =\n        { value: undefined,\n          writable: true,\n          enumerable: true,\n          configurable: true };\n    }\n\n    // we now know that ownDesc !== undefined\n    if (isAccessorDescriptor(ownDesc)) {\n      var setter = ownDesc.set;\n      if (setter === undefined) return false;\n      setter.call(receiver, value); // assumes Function.prototype.call\n      return true;\n    }\n    // otherwise, isDataDescriptor(ownDesc) must be true\n    if (ownDesc.writable === false) return false;\n    // we found an existing writable data property on the prototype chain.\n    // Now update or add the data property on the receiver, depending on\n    // whether the receiver already defines the property or not.\n    var existingDesc = Object.getOwnPropertyDescriptor(receiver, name);\n    if (existingDesc !== undefined) {\n      var updateDesc =\n        { value: value,\n          // FIXME: it should not be necessary to describe the following\n          // attributes. Added to circumvent a bug in tracemonkey:\n          // https://bugzilla.mozilla.org/show_bug.cgi?id=601329\n          writable:     existingDesc.writable,\n          enumerable:   existingDesc.enumerable,\n          configurable: existingDesc.configurable };\n      Object.defineProperty(receiver, name, updateDesc);\n      return true;\n    } else {\n      if (!Object.isExtensible(receiver)) return false;\n      var newDesc =\n        { value: value,\n          writable: true,\n          enumerable: true,\n          configurable: true };\n      Object.defineProperty(receiver, name, newDesc);\n      return true;\n    }\n  },\n  /*invoke: function(target, name, args, receiver) {\n    receiver = receiver || target;\n\n    var handler = directProxies.get(target);\n    if (handler !== undefined) {\n      return handler.invoke(receiver, name, args);\n    }\n\n    var fun = Reflect.get(target, name, receiver);\n    return Function.prototype.apply.call(fun, receiver, args);\n  },*/\n  enumerate: function(target) {\n    var handler = directProxies.get(target);\n    var result;\n    if (handler !== undefined) {\n      // handler.enumerate should return an iterator directly, but the\n      // iterator gets converted to an array for backward-compat reasons,\n      // so we must re-iterate over the array\n      result = handler.enumerate(handler.target);\n    } else {\n      result = [];\n      for (var name in target) { result.push(name); };      \n    }\n    var l = +result.length;\n    var idx = 0;\n    return {\n      next: function() {\n        if (idx === l) return { done: true };\n        return { done: false, value: result[idx++] };\n      }\n    };\n  },\n  // imperfect ownKeys implementation: in ES6, should also include\n  // symbol-keyed properties.\n  ownKeys: function(target) {\n    return Object_getOwnPropertyNames(target);\n  },\n  apply: function(target, receiver, args) {\n    // target.apply(receiver, args)\n    return Function.prototype.apply.call(target, receiver, args);\n  },\n  construct: function(target, args, newTarget) {\n    // return new target(...args);\n\n    // if target is a proxy, invoke its \"construct\" trap\n    var handler = directProxies.get(target);\n    if (handler !== undefined) {\n      return handler.construct(handler.target, args, newTarget);\n    }\n    \n    if (typeof target !== \"function\") {\n      throw new TypeError(\"target is not a function: \" + target);\n    }\n    if (newTarget === undefined) {\n      newTarget = target;\n    } else {\n      if (typeof newTarget !== \"function\") {\n        throw new TypeError(\"newTarget is not a function: \" + target);\n      }      \n    }\n\n    return new (Function.prototype.bind.apply(newTarget, [null].concat(args)));\n  }\n};\n\n// feature-test whether the Proxy global exists, with\n// the harmony-era Proxy.create API\nif (typeof Proxy !== \"undefined\" &&\n    typeof Proxy.create !== \"undefined\") {\n\n  var primCreate = Proxy.create,\n      primCreateFunction = Proxy.createFunction;\n\n  var revokedHandler = primCreate({\n    get: function() { throw new TypeError(\"proxy is revoked\"); }\n  });\n\n  global.Proxy = function(target, handler) {\n    // check that target is an Object\n    if (Object(target) !== target) {\n      throw new TypeError(\"Proxy target must be an Object, given \"+target);\n    }\n    // check that handler is an Object\n    if (Object(handler) !== handler) {\n      throw new TypeError(\"Proxy handler must be an Object, given \"+handler);\n    }\n\n    var vHandler = new Validator(target, handler);\n    var proxy;\n    if (typeof target === \"function\") {\n      proxy = primCreateFunction(vHandler,\n        // call trap\n        function() {\n          var args = Array.prototype.slice.call(arguments);\n          return vHandler.apply(target, this, args);\n        },\n        // construct trap\n        function() {\n          var args = Array.prototype.slice.call(arguments);\n          return vHandler.construct(target, args);\n        });\n    } else {\n      proxy = primCreate(vHandler, Object.getPrototypeOf(target));\n    }\n    directProxies.set(proxy, vHandler);\n    return proxy;\n  };\n\n  global.Proxy.revocable = function(target, handler) {\n    var proxy = new Proxy(target, handler);\n    var revoke = function() {\n      var vHandler = directProxies.get(proxy);\n      if (vHandler !== null) {\n        vHandler.target  = null;\n        vHandler.handler = revokedHandler;\n      }\n      return undefined;\n    };\n    return {proxy: proxy, revoke: revoke};\n  }\n  \n  // add the old Proxy.create and Proxy.createFunction methods\n  // so old code that still depends on the harmony-era Proxy object\n  // is not broken. Also ensures that multiple versions of this\n  // library should load fine\n  global.Proxy.create = primCreate;\n  global.Proxy.createFunction = primCreateFunction;\n\n} else {\n  // Proxy global not defined, or old API not available\n  if (typeof Proxy === \"undefined\") {\n    // Proxy global not defined, add a Proxy function stub\n    global.Proxy = function(_target, _handler) {\n      throw new Error(\"proxies not supported on this platform. On v8/node/iojs, make sure to pass the --harmony_proxies flag\");\n    };\n  }\n  // Proxy global defined but old API not available\n  // presumably Proxy global already supports new API, leave untouched\n}\n\n// for node.js modules, export every property in the Reflect object\n// as part of the module interface\nif (true) {\n  Object.keys(Reflect).forEach(function (key) {\n    exports[key] = Reflect[key];\n  });\n}\n\n// function-as-module pattern\n}( true ? global : this));\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(260)))\n\n/***/ }),\n\n/***/ 260:\n/***/ (function(module, exports) {\n\nvar g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// 4.df4d30df57e3e986481f.chunk.js","// Copyright (C) 2011-2012 Software Languages Lab, Vrije Universiteit Brussel\n// This code is dual-licensed under both the Apache License and the MPL\n\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/* Version: MPL 1.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is a shim for the ES-Harmony reflection module\n *\n * The Initial Developer of the Original Code is\n * Tom Van Cutsem, Vrije Universiteit Brussel.\n * Portions created by the Initial Developer are Copyright (C) 2011-2012\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *\n */\n\n // ----------------------------------------------------------------------------\n\n // This file is a polyfill for the upcoming ECMAScript Reflect API,\n // including support for Proxies. See the draft specification at:\n // http://wiki.ecmascript.org/doku.php?id=harmony:reflect_api\n // http://wiki.ecmascript.org/doku.php?id=harmony:direct_proxies\n\n // For an implementation of the Handler API, see handlers.js, which implements:\n // http://wiki.ecmascript.org/doku.php?id=harmony:virtual_object_api\n\n // This implementation supersedes the earlier polyfill at:\n // code.google.com/p/es-lab/source/browse/trunk/src/proxies/DirectProxies.js\n\n // This code was tested on tracemonkey / Firefox 12\n//  (and should run fine on older Firefox versions starting with FF4)\n // The code also works correctly on\n //   v8 --harmony_proxies --harmony_weakmaps (v3.6.5.1)\n\n // Language Dependencies:\n //  - ECMAScript 5/strict\n //  - \"old\" (i.e. non-direct) Harmony Proxies\n //  - Harmony WeakMaps\n // Patches:\n //  - Object.{freeze,seal,preventExtensions}\n //  - Object.{isFrozen,isSealed,isExtensible}\n //  - Object.getPrototypeOf\n //  - Object.keys\n //  - Object.prototype.valueOf\n //  - Object.prototype.isPrototypeOf\n //  - Object.prototype.toString\n //  - Object.prototype.hasOwnProperty\n //  - Object.getOwnPropertyDescriptor\n //  - Object.defineProperty\n //  - Object.defineProperties\n //  - Object.getOwnPropertyNames\n //  - Object.getOwnPropertySymbols\n //  - Object.getPrototypeOf\n //  - Object.setPrototypeOf\n //  - Object.assign\n //  - Function.prototype.toString\n //  - Date.prototype.toString\n //  - Array.isArray\n //  - Array.prototype.concat\n //  - Proxy\n // Adds new globals:\n //  - Reflect\n\n // Direct proxies can be created via Proxy(target, handler)\n\n // ----------------------------------------------------------------------------\n\n(function(global){ // function-as-module pattern\n\"use strict\";\n\n// === Direct Proxies: Invariant Enforcement ===\n\n// Direct proxies build on non-direct proxies by automatically wrapping\n// all user-defined proxy handlers in a Validator handler that checks and\n// enforces ES5 invariants.\n\n// A direct proxy is a proxy for an existing object called the target object.\n\n// A Validator handler is a wrapper for a target proxy handler H.\n// The Validator forwards all operations to H, but additionally\n// performs a number of integrity checks on the results of some traps,\n// to make sure H does not violate the ES5 invariants w.r.t. non-configurable\n// properties and non-extensible, sealed or frozen objects.\n\n// For each property that H exposes as own, non-configurable\n// (e.g. by returning a descriptor from a call to getOwnPropertyDescriptor)\n// the Validator handler defines those properties on the target object.\n// When the proxy becomes non-extensible, also configurable own properties\n// are checked against the target.\n// We will call properties that are defined on the target object\n// \"fixed properties\".\n\n// We will name fixed non-configurable properties \"sealed properties\".\n// We will name fixed non-configurable non-writable properties \"frozen\n// properties\".\n\n// The Validator handler upholds the following invariants w.r.t. non-configurability:\n// - getOwnPropertyDescriptor cannot report sealed properties as non-existent\n// - getOwnPropertyDescriptor cannot report incompatible changes to the\n//   attributes of a sealed property (e.g. reporting a non-configurable\n//   property as configurable, or reporting a non-configurable, non-writable\n//   property as writable)\n// - getPropertyDescriptor cannot report sealed properties as non-existent\n// - getPropertyDescriptor cannot report incompatible changes to the\n//   attributes of a sealed property. It _can_ report incompatible changes\n//   to the attributes of non-own, inherited properties.\n// - defineProperty cannot make incompatible changes to the attributes of\n//   sealed properties\n// - deleteProperty cannot report a successful deletion of a sealed property\n// - hasOwn cannot report a sealed property as non-existent\n// - has cannot report a sealed property as non-existent\n// - get cannot report inconsistent values for frozen data\n//   properties, and must report undefined for sealed accessors with an\n//   undefined getter\n// - set cannot report a successful assignment for frozen data\n//   properties or sealed accessors with an undefined setter.\n// - get{Own}PropertyNames lists all sealed properties of the target.\n// - keys lists all enumerable sealed properties of the target.\n// - enumerate lists all enumerable sealed properties of the target.\n// - if a property of a non-extensible proxy is reported as non-existent,\n//   then it must forever be reported as non-existent. This applies to\n//   own and inherited properties and is enforced in the\n//   deleteProperty, get{Own}PropertyDescriptor, has{Own},\n//   get{Own}PropertyNames, keys and enumerate traps\n\n// Violation of any of these invariants by H will result in TypeError being\n// thrown.\n\n// Additionally, once Object.preventExtensions, Object.seal or Object.freeze\n// is invoked on the proxy, the set of own property names for the proxy is\n// fixed. Any property name that is not fixed is called a 'new' property.\n\n// The Validator upholds the following invariants regarding extensibility:\n// - getOwnPropertyDescriptor cannot report new properties as existent\n//   (it must report them as non-existent by returning undefined)\n// - defineProperty cannot successfully add a new property (it must reject)\n// - getOwnPropertyNames cannot list new properties\n// - hasOwn cannot report true for new properties (it must report false)\n// - keys cannot list new properties\n\n// Invariants currently not enforced:\n// - getOwnPropertyNames lists only own property names\n// - keys lists only enumerable own property names\n// Both traps may list more property names than are actually defined on the\n// target.\n\n// Invariants with regard to inheritance are currently not enforced.\n// - a non-configurable potentially inherited property on a proxy with\n//   non-mutable ancestry cannot be reported as non-existent\n// (An object with non-mutable ancestry is a non-extensible object whose\n// [[Prototype]] is either null or an object with non-mutable ancestry.)\n\n// Changes in Handler API compared to previous harmony:proxies, see:\n// http://wiki.ecmascript.org/doku.php?id=strawman:direct_proxies\n// http://wiki.ecmascript.org/doku.php?id=harmony:direct_proxies\n\n// ----------------------------------------------------------------------------\n\n// ---- WeakMap polyfill ----\n\n// TODO: find a proper WeakMap polyfill\n\n// define an empty WeakMap so that at least the Reflect module code\n// will work in the absence of WeakMaps. Proxy emulation depends on\n// actual WeakMaps, so will not work with this little shim.\nif (typeof WeakMap === \"undefined\") {\n  global.WeakMap = function(){};\n  global.WeakMap.prototype = {\n    get: function(k) { return undefined; },\n    set: function(k,v) { throw new Error(\"WeakMap not supported\"); }\n  };\n}\n\n// ---- Normalization functions for property descriptors ----\n\nfunction isStandardAttribute(name) {\n  return /^(get|set|value|writable|enumerable|configurable)$/.test(name);\n}\n\n// Adapted from ES5 section 8.10.5\nfunction toPropertyDescriptor(obj) {\n  if (Object(obj) !== obj) {\n    throw new TypeError(\"property descriptor should be an Object, given: \"+\n                        obj);\n  }\n  var desc = {};\n  if ('enumerable' in obj) { desc.enumerable = !!obj.enumerable; }\n  if ('configurable' in obj) { desc.configurable = !!obj.configurable; }\n  if ('value' in obj) { desc.value = obj.value; }\n  if ('writable' in obj) { desc.writable = !!obj.writable; }\n  if ('get' in obj) {\n    var getter = obj.get;\n    if (getter !== undefined && typeof getter !== \"function\") {\n      throw new TypeError(\"property descriptor 'get' attribute must be \"+\n                          \"callable or undefined, given: \"+getter);\n    }\n    desc.get = getter;\n  }\n  if ('set' in obj) {\n    var setter = obj.set;\n    if (setter !== undefined && typeof setter !== \"function\") {\n      throw new TypeError(\"property descriptor 'set' attribute must be \"+\n                          \"callable or undefined, given: \"+setter);\n    }\n    desc.set = setter;\n  }\n  if ('get' in desc || 'set' in desc) {\n    if ('value' in desc || 'writable' in desc) {\n      throw new TypeError(\"property descriptor cannot be both a data and an \"+\n                          \"accessor descriptor: \"+obj);\n    }\n  }\n  return desc;\n}\n\nfunction isAccessorDescriptor(desc) {\n  if (desc === undefined) return false;\n  return ('get' in desc || 'set' in desc);\n}\nfunction isDataDescriptor(desc) {\n  if (desc === undefined) return false;\n  return ('value' in desc || 'writable' in desc);\n}\nfunction isGenericDescriptor(desc) {\n  if (desc === undefined) return false;\n  return !isAccessorDescriptor(desc) && !isDataDescriptor(desc);\n}\n\nfunction toCompletePropertyDescriptor(desc) {\n  var internalDesc = toPropertyDescriptor(desc);\n  if (isGenericDescriptor(internalDesc) || isDataDescriptor(internalDesc)) {\n    if (!('value' in internalDesc)) { internalDesc.value = undefined; }\n    if (!('writable' in internalDesc)) { internalDesc.writable = false; }\n  } else {\n    if (!('get' in internalDesc)) { internalDesc.get = undefined; }\n    if (!('set' in internalDesc)) { internalDesc.set = undefined; }\n  }\n  if (!('enumerable' in internalDesc)) { internalDesc.enumerable = false; }\n  if (!('configurable' in internalDesc)) { internalDesc.configurable = false; }\n  return internalDesc;\n}\n\nfunction isEmptyDescriptor(desc) {\n  return !('get' in desc) &&\n         !('set' in desc) &&\n         !('value' in desc) &&\n         !('writable' in desc) &&\n         !('enumerable' in desc) &&\n         !('configurable' in desc);\n}\n\nfunction isEquivalentDescriptor(desc1, desc2) {\n  return sameValue(desc1.get, desc2.get) &&\n         sameValue(desc1.set, desc2.set) &&\n         sameValue(desc1.value, desc2.value) &&\n         sameValue(desc1.writable, desc2.writable) &&\n         sameValue(desc1.enumerable, desc2.enumerable) &&\n         sameValue(desc1.configurable, desc2.configurable);\n}\n\n// copied from http://wiki.ecmascript.org/doku.php?id=harmony:egal\nfunction sameValue(x, y) {\n  if (x === y) {\n    // 0 === -0, but they are not identical\n    return x !== 0 || 1 / x === 1 / y;\n  }\n\n  // NaN !== NaN, but they are identical.\n  // NaNs are the only non-reflexive value, i.e., if x !== x,\n  // then x is a NaN.\n  // isNaN is broken: it converts its argument to number, so\n  // isNaN(\"foo\") => true\n  return x !== x && y !== y;\n}\n\n/**\n * Returns a fresh property descriptor that is guaranteed\n * to be complete (i.e. contain all the standard attributes).\n * Additionally, any non-standard enumerable properties of\n * attributes are copied over to the fresh descriptor.\n *\n * If attributes is undefined, returns undefined.\n *\n * See also: http://wiki.ecmascript.org/doku.php?id=harmony:proxies_semantics\n */\nfunction normalizeAndCompletePropertyDescriptor(attributes) {\n  if (attributes === undefined) { return undefined; }\n  var desc = toCompletePropertyDescriptor(attributes);\n  // Note: no need to call FromPropertyDescriptor(desc), as we represent\n  // \"internal\" property descriptors as proper Objects from the start\n  for (var name in attributes) {\n    if (!isStandardAttribute(name)) {\n      Object.defineProperty(desc, name,\n        { value: attributes[name],\n          writable: true,\n          enumerable: true,\n          configurable: true });\n    }\n  }\n  return desc;\n}\n\n/**\n * Returns a fresh property descriptor whose standard\n * attributes are guaranteed to be data properties of the right type.\n * Additionally, any non-standard enumerable properties of\n * attributes are copied over to the fresh descriptor.\n *\n * If attributes is undefined, will throw a TypeError.\n *\n * See also: http://wiki.ecmascript.org/doku.php?id=harmony:proxies_semantics\n */\nfunction normalizePropertyDescriptor(attributes) {\n  var desc = toPropertyDescriptor(attributes);\n  // Note: no need to call FromGenericPropertyDescriptor(desc), as we represent\n  // \"internal\" property descriptors as proper Objects from the start\n  for (var name in attributes) {\n    if (!isStandardAttribute(name)) {\n      Object.defineProperty(desc, name,\n        { value: attributes[name],\n          writable: true,\n          enumerable: true,\n          configurable: true });\n    }\n  }\n  return desc;\n}\n\n// store a reference to the real ES5 primitives before patching them later\nvar prim_preventExtensions =        Object.preventExtensions,\n    prim_seal =                     Object.seal,\n    prim_freeze =                   Object.freeze,\n    prim_isExtensible =             Object.isExtensible,\n    prim_isSealed =                 Object.isSealed,\n    prim_isFrozen =                 Object.isFrozen,\n    prim_getPrototypeOf =           Object.getPrototypeOf,\n    prim_getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor,\n    prim_defineProperty =           Object.defineProperty,\n    prim_defineProperties =         Object.defineProperties,\n    prim_keys =                     Object.keys,\n    prim_getOwnPropertyNames =      Object.getOwnPropertyNames,\n    prim_getOwnPropertySymbols =    Object.getOwnPropertySymbols,\n    prim_assign =                   Object.assign,\n    prim_isArray =                  Array.isArray,\n    prim_concat =                   Array.prototype.concat,\n    prim_isPrototypeOf =            Object.prototype.isPrototypeOf,\n    prim_hasOwnProperty =           Object.prototype.hasOwnProperty;\n\n// these will point to the patched versions of the respective methods on\n// Object. They are used within this module as the \"intrinsic\" bindings\n// of these methods (i.e. the \"original\" bindings as defined in the spec)\nvar Object_isFrozen,\n    Object_isSealed,\n    Object_isExtensible,\n    Object_getPrototypeOf,\n    Object_getOwnPropertyNames;\n\n/**\n * A property 'name' is fixed if it is an own property of the target.\n */\nfunction isFixed(name, target) {\n  return ({}).hasOwnProperty.call(target, name);\n}\nfunction isSealed(name, target) {\n  var desc = Object.getOwnPropertyDescriptor(target, name);\n  if (desc === undefined) { return false; }\n  return desc.configurable === false;\n}\nfunction isSealedDesc(desc) {\n  return desc !== undefined && desc.configurable === false;\n}\n\n/**\n * Performs all validation that Object.defineProperty performs,\n * without actually defining the property. Returns a boolean\n * indicating whether validation succeeded.\n *\n * Implementation transliterated from ES5.1 section 8.12.9\n */\nfunction isCompatibleDescriptor(extensible, current, desc) {\n  if (current === undefined && extensible === false) {\n    return false;\n  }\n  if (current === undefined && extensible === true) {\n    return true;\n  }\n  if (isEmptyDescriptor(desc)) {\n    return true;\n  }\n  if (isEquivalentDescriptor(current, desc)) {\n    return true;\n  }\n  if (current.configurable === false) {\n    if (desc.configurable === true) {\n      return false;\n    }\n    if ('enumerable' in desc && desc.enumerable !== current.enumerable) {\n      return false;\n    }\n  }\n  if (isGenericDescriptor(desc)) {\n    return true;\n  }\n  if (isDataDescriptor(current) !== isDataDescriptor(desc)) {\n    if (current.configurable === false) {\n      return false;\n    }\n    return true;\n  }\n  if (isDataDescriptor(current) && isDataDescriptor(desc)) {\n    if (current.configurable === false) {\n      if (current.writable === false && desc.writable === true) {\n        return false;\n      }\n      if (current.writable === false) {\n        if ('value' in desc && !sameValue(desc.value, current.value)) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n  if (isAccessorDescriptor(current) && isAccessorDescriptor(desc)) {\n    if (current.configurable === false) {\n      if ('set' in desc && !sameValue(desc.set, current.set)) {\n        return false;\n      }\n      if ('get' in desc && !sameValue(desc.get, current.get)) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\n// ES6 7.3.11 SetIntegrityLevel\n// level is one of \"sealed\" or \"frozen\"\nfunction setIntegrityLevel(target, level) {\n  var ownProps = Object_getOwnPropertyNames(target);\n  var pendingException = undefined;\n  if (level === \"sealed\") {\n    var l = +ownProps.length;\n    var k;\n    for (var i = 0; i < l; i++) {\n      k = String(ownProps[i]);\n      try {\n        Object.defineProperty(target, k, { configurable: false });\n      } catch (e) {\n        if (pendingException === undefined) {\n          pendingException = e;\n        }\n      }\n    }\n  } else {\n    // level === \"frozen\"\n    var l = +ownProps.length;\n    var k;\n    for (var i = 0; i < l; i++) {\n      k = String(ownProps[i]);\n      try {\n        var currentDesc = Object.getOwnPropertyDescriptor(target, k);\n        if (currentDesc !== undefined) {\n          var desc;\n          if (isAccessorDescriptor(currentDesc)) {\n            desc = { configurable: false }\n          } else {\n            desc = { configurable: false, writable: false }\n          }\n          Object.defineProperty(target, k, desc);\n        }        \n      } catch (e) {\n        if (pendingException === undefined) {\n          pendingException = e;\n        }\n      }\n    }\n  }\n  if (pendingException !== undefined) {\n    throw pendingException;\n  }\n  return Reflect.preventExtensions(target);\n}\n\n// ES6 7.3.12 TestIntegrityLevel\n// level is one of \"sealed\" or \"frozen\"\nfunction testIntegrityLevel(target, level) {\n  var isExtensible = Object_isExtensible(target);\n  if (isExtensible) return false;\n  \n  var ownProps = Object_getOwnPropertyNames(target);\n  var pendingException = undefined;\n  var configurable = false;\n  var writable = false;\n  \n  var l = +ownProps.length;\n  var k;\n  var currentDesc;\n  for (var i = 0; i < l; i++) {\n    k = String(ownProps[i]);\n    try {\n      currentDesc = Object.getOwnPropertyDescriptor(target, k);\n      configurable = configurable || currentDesc.configurable;\n      if (isDataDescriptor(currentDesc)) {\n        writable = writable || currentDesc.writable;\n      }\n    } catch (e) {\n      if (pendingException === undefined) {\n        pendingException = e;\n        configurable = true;\n      }\n    }\n  }\n  if (pendingException !== undefined) {\n    throw pendingException;\n  }\n  if (level === \"frozen\" && writable === true) {\n    return false;\n  }\n  if (configurable === true) {\n    return false;\n  }\n  return true;\n}\n\n// ---- The Validator handler wrapper around user handlers ----\n\n/**\n * @param target the object wrapped by this proxy.\n * As long as the proxy is extensible, only non-configurable properties\n * are checked against the target. Once the proxy becomes non-extensible,\n * invariants w.r.t. non-extensibility are also enforced.\n *\n * @param handler the handler of the direct proxy. The object emulated by\n * this handler is validated against the target object of the direct proxy.\n * Any violations that the handler makes against the invariants\n * of the target will cause a TypeError to be thrown.\n *\n * Both target and handler must be proper Objects at initialization time.\n */\nfunction Validator(target, handler) {\n  // for non-revokable proxies, these are const references\n  // for revokable proxies, on revocation:\n  // - this.target is set to null\n  // - this.handler is set to a handler that throws on all traps\n  this.target  = target;\n  this.handler = handler;\n}\n\nValidator.prototype = {\n\n  /**\n   * If getTrap returns undefined, the caller should perform the\n   * default forwarding behavior.\n   * If getTrap returns normally otherwise, the return value\n   * will be a callable trap function. When calling the trap function,\n   * the caller is responsible for binding its |this| to |this.handler|.\n   */\n  getTrap: function(trapName) {\n    var trap = this.handler[trapName];\n    if (trap === undefined) {\n      // the trap was not defined,\n      // perform the default forwarding behavior\n      return undefined;\n    }\n\n    if (typeof trap !== \"function\") {\n      throw new TypeError(trapName + \" trap is not callable: \"+trap);\n    }\n\n    return trap;\n  },\n\n  // === fundamental traps ===\n\n  /**\n   * If name denotes a fixed property, check:\n   *   - whether targetHandler reports it as existent\n   *   - whether the returned descriptor is compatible with the fixed property\n   * If the proxy is non-extensible, check:\n   *   - whether name is not a new property\n   * Additionally, the returned descriptor is normalized and completed.\n   */\n  getOwnPropertyDescriptor: function(name) {\n    \"use strict\";\n\n    var trap = this.getTrap(\"getOwnPropertyDescriptor\");\n    if (trap === undefined) {\n      return Reflect.getOwnPropertyDescriptor(this.target, name);\n    }\n\n    name = String(name);\n    var desc = trap.call(this.handler, this.target, name);\n    desc = normalizeAndCompletePropertyDescriptor(desc);\n\n    var targetDesc = Object.getOwnPropertyDescriptor(this.target, name);\n    var extensible = Object.isExtensible(this.target);\n\n    if (desc === undefined) {\n      if (isSealedDesc(targetDesc)) {\n        throw new TypeError(\"cannot report non-configurable property '\"+name+\n                            \"' as non-existent\");\n      }\n      if (!extensible && targetDesc !== undefined) {\n          // if handler is allowed to return undefined, we cannot guarantee\n          // that it will not return a descriptor for this property later.\n          // Once a property has been reported as non-existent on a non-extensible\n          // object, it should forever be reported as non-existent\n          throw new TypeError(\"cannot report existing own property '\"+name+\n                              \"' as non-existent on a non-extensible object\");\n      }\n      return undefined;\n    }\n\n    // at this point, we know (desc !== undefined), i.e.\n    // targetHandler reports 'name' as an existing property\n\n    // Note: we could collapse the following two if-tests into a single\n    // test. Separating out the cases to improve error reporting.\n\n    if (!extensible) {\n      if (targetDesc === undefined) {\n        throw new TypeError(\"cannot report a new own property '\"+\n                            name + \"' on a non-extensible object\");\n      }\n    }\n\n    if (name !== undefined) {\n      if (!isCompatibleDescriptor(extensible, targetDesc, desc)) {\n        throw new TypeError(\"cannot report incompatible property descriptor \"+\n                            \"for property '\"+name+\"'\");\n      }\n    }\n    \n    if (desc.configurable === false) {\n      if (targetDesc === undefined || targetDesc.configurable === true) {\n        // if the property is configurable or non-existent on the target,\n        // but is reported as a non-configurable property, it may later be\n        // reported as configurable or non-existent, which violates the\n        // invariant that if the property might change or disappear, the\n        // configurable attribute must be true.\n        throw new TypeError(\n          \"cannot report a non-configurable descriptor \" +\n          \"for configurable or non-existent property '\" + name + \"'\");\n      }\n      if ('writable' in desc && desc.writable === false) {\n        if (targetDesc.writable === true) {\n          // if the property is non-configurable, writable on the target,\n          // but is reported as non-configurable, non-writable, it may later\n          // be reported as non-configurable, writable again, which violates\n          // the invariant that a non-configurable, non-writable property\n          // may not change state.\n          throw new TypeError(\n            \"cannot report non-configurable, writable property '\" + name +\n            \"' as non-configurable, non-writable\");\n        }\n      }\n    }\n\n    return desc;\n  },\n\n  /**\n   * In the direct proxies design with refactored prototype climbing,\n   * this trap is deprecated. For proxies-as-prototypes, instead\n   * of calling this trap, the get, set, has or enumerate traps are\n   * called instead.\n   *\n   * In this implementation, we \"abuse\" getPropertyDescriptor to\n   * support trapping the get or set traps for proxies-as-prototypes.\n   * We do this by returning a getter/setter pair that invokes\n   * the corresponding traps.\n   *\n   * While this hack works for inherited property access, it has some\n   * quirks:\n   *\n   * In Firefox, this trap is only called after a prior invocation\n   * of the 'has' trap has returned true. Hence, expect the following\n   * behavior:\n   * <code>\n   * var child = Object.create(Proxy(target, handler));\n   * child[name] // triggers handler.has(target, name)\n   * // if that returns true, triggers handler.get(target, name, child)\n   * </code>\n   *\n   * On v8, the 'in' operator, when applied to an object that inherits\n   * from a proxy, will call getPropertyDescriptor and walk the proto-chain.\n   * That calls the below getPropertyDescriptor trap on the proxy. The\n   * result of the 'in'-operator is then determined by whether this trap\n   * returns undefined or a property descriptor object. That is why\n   * we first explicitly trigger the 'has' trap to determine whether\n   * the property exists.\n   *\n   * This has the side-effect that when enumerating properties on\n   * an object that inherits from a proxy in v8, only properties\n   * for which 'has' returns true are returned:\n   *\n   * <code>\n   * var child = Object.create(Proxy(target, handler));\n   * for (var prop in child) {\n   *   // only enumerates prop if (prop in child) returns true\n   * }\n   * </code>\n   */\n  getPropertyDescriptor: function(name) {\n    var handler = this;\n\n    if (!handler.has(name)) return undefined;\n\n    return {\n      get: function() {\n        return handler.get(this, name);\n      },\n      set: function(val) {\n        if (handler.set(this, name, val)) {\n          return val;\n        } else {\n          throw new TypeError(\"failed assignment to \"+name);\n        }\n      },\n      enumerable: true,\n      configurable: true\n    };\n  },\n\n  /**\n   * If name denotes a fixed property, check for incompatible changes.\n   * If the proxy is non-extensible, check that new properties are rejected.\n   */\n  defineProperty: function(name, desc) {\n    // TODO(tvcutsem): the current tracemonkey implementation of proxies\n    // auto-completes 'desc', which is not correct. 'desc' should be\n    // normalized, but not completed. Consider:\n    // Object.defineProperty(proxy, 'foo', {enumerable:false})\n    // This trap will receive desc =\n    //  {value:undefined,writable:false,enumerable:false,configurable:false}\n    // This will also set all other attributes to their default value,\n    // which is unexpected and different from [[DefineOwnProperty]].\n    // Bug filed: https://bugzilla.mozilla.org/show_bug.cgi?id=601329\n\n    var trap = this.getTrap(\"defineProperty\");\n    if (trap === undefined) {\n      // default forwarding behavior\n      return Reflect.defineProperty(this.target, name, desc);\n    }\n\n    name = String(name);\n    var descObj = normalizePropertyDescriptor(desc);\n    var success = trap.call(this.handler, this.target, name, descObj);\n    success = !!success; // coerce to Boolean\n\n    if (success === true) {\n\n      var targetDesc = Object.getOwnPropertyDescriptor(this.target, name);\n      var extensible = Object.isExtensible(this.target);\n\n      // Note: we could collapse the following two if-tests into a single\n      // test. Separating out the cases to improve error reporting.\n\n      if (!extensible) {\n        if (targetDesc === undefined) {\n          throw new TypeError(\"cannot successfully add a new property '\"+\n                              name + \"' to a non-extensible object\");\n        }\n      }\n\n      if (targetDesc !== undefined) {\n        if (!isCompatibleDescriptor(extensible, targetDesc, desc)) {\n          throw new TypeError(\"cannot define incompatible property \"+\n                              \"descriptor for property '\"+name+\"'\");\n        }\n        if (isDataDescriptor(targetDesc) &&\n            targetDesc.configurable === false &&\n            targetDesc.writable === true) {\n            if (desc.configurable === false && desc.writable === false) {\n              // if the property is non-configurable, writable on the target\n              // but was successfully reported to be updated to\n              // non-configurable, non-writable, it can later be reported\n              // again as non-configurable, writable, which violates\n              // the invariant that non-configurable, non-writable properties\n              // cannot change state\n              throw new TypeError(\n                \"cannot successfully define non-configurable, writable \" +\n                \" property '\" + name + \"' as non-configurable, non-writable\");\n            }\n          }\n      }\n\n      if (desc.configurable === false && !isSealedDesc(targetDesc)) {\n        // if the property is configurable or non-existent on the target,\n        // but is successfully being redefined as a non-configurable property,\n        // it may later be reported as configurable or non-existent, which violates\n        // the invariant that if the property might change or disappear, the\n        // configurable attribute must be true.\n        throw new TypeError(\n          \"cannot successfully define a non-configurable \" +\n          \"descriptor for configurable or non-existent property '\" +\n          name + \"'\");\n      }\n\n    }\n\n    return success;\n  },\n\n  /**\n   * On success, check whether the target object is indeed non-extensible.\n   */\n  preventExtensions: function() {\n    var trap = this.getTrap(\"preventExtensions\");\n    if (trap === undefined) {\n      // default forwarding behavior\n      return Reflect.preventExtensions(this.target);\n    }\n\n    var success = trap.call(this.handler, this.target);\n    success = !!success; // coerce to Boolean\n    if (success) {\n      if (Object_isExtensible(this.target)) {\n        throw new TypeError(\"can't report extensible object as non-extensible: \"+\n                            this.target);\n      }\n    }\n    return success;\n  },\n\n  /**\n   * If name denotes a sealed property, check whether handler rejects.\n   */\n  delete: function(name) {\n    \"use strict\";\n    var trap = this.getTrap(\"deleteProperty\");\n    if (trap === undefined) {\n      // default forwarding behavior\n      return Reflect.deleteProperty(this.target, name);\n    }\n\n    name = String(name);\n    var res = trap.call(this.handler, this.target, name);\n    res = !!res; // coerce to Boolean\n\n    var targetDesc;\n    if (res === true) {\n      targetDesc = Object.getOwnPropertyDescriptor(this.target, name);\n      if (targetDesc !== undefined && targetDesc.configurable === false) {\n        throw new TypeError(\"property '\" + name + \"' is non-configurable \"+\n                            \"and can't be deleted\");\n      }\n      if (targetDesc !== undefined && !Object_isExtensible(this.target)) {\n        // if the property still exists on a non-extensible target but\n        // is reported as successfully deleted, it may later be reported\n        // as present, which violates the invariant that an own property,\n        // deleted from a non-extensible object cannot reappear.\n        throw new TypeError(\n          \"cannot successfully delete existing property '\" + name +\n          \"' on a non-extensible object\");\n      }\n    }\n\n    return res;\n  },\n\n  /**\n   * The getOwnPropertyNames trap was replaced by the ownKeys trap,\n   * which now also returns an array (of strings or symbols) and\n   * which performs the same rigorous invariant checks as getOwnPropertyNames\n   *\n   * See issue #48 on how this trap can still get invoked by external libs\n   * that don't use the patched Object.getOwnPropertyNames function.\n   */\n  getOwnPropertyNames: function() {\n    // Note: removed deprecation warning to avoid dependency on 'console'\n    // (and on node, should anyway use util.deprecate). Deprecation warnings\n    // can also be annoying when they are outside of the user's control, e.g.\n    // when an external library calls unpatched Object.getOwnPropertyNames.\n    // Since there is a clean fallback to `ownKeys`, the fact that the\n    // deprecated method is still called is mostly harmless anyway.\n    // See also issues #65 and #66.\n    // console.warn(\"getOwnPropertyNames trap is deprecated. Use ownKeys instead\");\n    return this.ownKeys();\n  },\n\n  /**\n   * Checks whether the trap result does not contain any new properties\n   * if the proxy is non-extensible.\n   *\n   * Any own non-configurable properties of the target that are not included\n   * in the trap result give rise to a TypeError. As such, we check whether the\n   * returned result contains at least all sealed properties of the target\n   * object.\n   *\n   * Additionally, the trap result is normalized.\n   * Instead of returning the trap result directly:\n   *  - create and return a fresh Array,\n   *  - of which each element is coerced to a String\n   *\n   * This trap is called a.o. by Reflect.ownKeys, Object.getOwnPropertyNames\n   * and Object.keys (the latter filters out only the enumerable own properties).\n   */\n  ownKeys: function() {\n    var trap = this.getTrap(\"ownKeys\");\n    if (trap === undefined) {\n      // default forwarding behavior\n      return Reflect.ownKeys(this.target);\n    }\n\n    var trapResult = trap.call(this.handler, this.target);\n\n    // propNames is used as a set of strings\n    var propNames = Object.create(null);\n    var numProps = +trapResult.length;\n    var result = new Array(numProps);\n\n    for (var i = 0; i < numProps; i++) {\n      var s = String(trapResult[i]);\n      if (!Object.isExtensible(this.target) && !isFixed(s, this.target)) {\n        // non-extensible proxies don't tolerate new own property names\n        throw new TypeError(\"ownKeys trap cannot list a new \"+\n                            \"property '\"+s+\"' on a non-extensible object\");\n      }\n\n      propNames[s] = true;\n      result[i] = s;\n    }\n\n    var ownProps = Object_getOwnPropertyNames(this.target);\n    var target = this.target;\n    ownProps.forEach(function (ownProp) {\n      if (!propNames[ownProp]) {\n        if (isSealed(ownProp, target)) {\n          throw new TypeError(\"ownKeys trap failed to include \"+\n                              \"non-configurable property '\"+ownProp+\"'\");\n        }\n        if (!Object.isExtensible(target) &&\n            isFixed(ownProp, target)) {\n            // if handler is allowed to report ownProp as non-existent,\n            // we cannot guarantee that it will never later report it as\n            // existent. Once a property has been reported as non-existent\n            // on a non-extensible object, it should forever be reported as\n            // non-existent\n            throw new TypeError(\"ownKeys trap cannot report existing own property '\"+\n                                ownProp+\"' as non-existent on a non-extensible object\");\n        }\n      }\n    });\n\n    return result;\n  },\n\n  /**\n   * Checks whether the trap result is consistent with the state of the\n   * wrapped target.\n   */\n  isExtensible: function() {\n    var trap = this.getTrap(\"isExtensible\");\n    if (trap === undefined) {\n      // default forwarding behavior\n      return Reflect.isExtensible(this.target);\n    }\n\n    var result = trap.call(this.handler, this.target);\n    result = !!result; // coerce to Boolean\n    var state = Object_isExtensible(this.target);\n    if (result !== state) {\n      if (result) {\n        throw new TypeError(\"cannot report non-extensible object as extensible: \"+\n                             this.target);\n      } else {\n        throw new TypeError(\"cannot report extensible object as non-extensible: \"+\n                             this.target);\n      }\n    }\n    return state;\n  },\n\n  /**\n   * Check whether the trap result corresponds to the target's [[Prototype]]\n   */\n  getPrototypeOf: function() {\n    var trap = this.getTrap(\"getPrototypeOf\");\n    if (trap === undefined) {\n      // default forwarding behavior\n      return Reflect.getPrototypeOf(this.target);\n    }\n\n    var allegedProto = trap.call(this.handler, this.target);\n\n    if (!Object_isExtensible(this.target)) {\n      var actualProto = Object_getPrototypeOf(this.target);\n      if (!sameValue(allegedProto, actualProto)) {\n        throw new TypeError(\"prototype value does not match: \" + this.target);\n      }\n    }\n\n    return allegedProto;\n  },\n\n  /**\n   * If target is non-extensible and setPrototypeOf trap returns true,\n   * check whether the trap result corresponds to the target's [[Prototype]]\n   */\n  setPrototypeOf: function(newProto) {\n    var trap = this.getTrap(\"setPrototypeOf\");\n    if (trap === undefined) {\n      // default forwarding behavior\n      return Reflect.setPrototypeOf(this.target, newProto);\n    }\n\n    var success = trap.call(this.handler, this.target, newProto);\n\n    success = !!success;\n    if (success && !Object_isExtensible(this.target)) {\n      var actualProto = Object_getPrototypeOf(this.target);\n      if (!sameValue(newProto, actualProto)) {\n        throw new TypeError(\"prototype value does not match: \" + this.target);\n      }\n    }\n\n    return success;\n  },\n\n  /**\n   * In the direct proxies design with refactored prototype climbing,\n   * this trap is deprecated. For proxies-as-prototypes, for-in will\n   * call the enumerate() trap. If that trap is not defined, the\n   * operation is forwarded to the target, no more fallback on this\n   * fundamental trap.\n   */\n  getPropertyNames: function() {\n    throw new TypeError(\"getPropertyNames trap is deprecated\");\n  },\n\n  // === derived traps ===\n\n  /**\n   * If name denotes a fixed property, check whether the trap returns true.\n   */\n  has: function(name) {\n    var trap = this.getTrap(\"has\");\n    if (trap === undefined) {\n      // default forwarding behavior\n      return Reflect.has(this.target, name);\n    }\n\n    name = String(name);\n    var res = trap.call(this.handler, this.target, name);\n    res = !!res; // coerce to Boolean\n\n    if (res === false) {\n      if (isSealed(name, this.target)) {\n        throw new TypeError(\"cannot report existing non-configurable own \"+\n                            \"property '\"+ name + \"' as a non-existent \"+\n                            \"property\");\n      }\n      if (!Object.isExtensible(this.target) &&\n          isFixed(name, this.target)) {\n          // if handler is allowed to return false, we cannot guarantee\n          // that it will not return true for this property later.\n          // Once a property has been reported as non-existent on a non-extensible\n          // object, it should forever be reported as non-existent\n          throw new TypeError(\"cannot report existing own property '\"+name+\n                              \"' as non-existent on a non-extensible object\");\n      }\n    }\n\n    // if res === true, we don't need to check for extensibility\n    // even for a non-extensible proxy that has no own name property,\n    // the property may have been inherited\n\n    return res;\n  },\n\n  /**\n   * If name denotes a fixed non-configurable, non-writable data property,\n   * check its return value against the previously asserted value of the\n   * fixed property.\n   */\n  get: function(receiver, name) {\n\n    // experimental support for invoke() trap on platforms that\n    // support __noSuchMethod__\n    /*\n    if (name === '__noSuchMethod__') {\n      var handler = this;\n      return function(name, args) {\n        return handler.invoke(receiver, name, args);\n      }\n    }\n    */\n\n    var trap = this.getTrap(\"get\");\n    if (trap === undefined) {\n      // default forwarding behavior\n      return Reflect.get(this.target, name, receiver);\n    }\n\n    name = String(name);\n    var res = trap.call(this.handler, this.target, name, receiver);\n\n    var fixedDesc = Object.getOwnPropertyDescriptor(this.target, name);\n    // check consistency of the returned value\n    if (fixedDesc !== undefined) { // getting an existing property\n      if (isDataDescriptor(fixedDesc) &&\n          fixedDesc.configurable === false &&\n          fixedDesc.writable === false) { // own frozen data property\n        if (!sameValue(res, fixedDesc.value)) {\n          throw new TypeError(\"cannot report inconsistent value for \"+\n                              \"non-writable, non-configurable property '\"+\n                              name+\"'\");\n        }\n      } else { // it's an accessor property\n        if (isAccessorDescriptor(fixedDesc) &&\n            fixedDesc.configurable === false &&\n            fixedDesc.get === undefined) {\n          if (res !== undefined) {\n            throw new TypeError(\"must report undefined for non-configurable \"+\n                                \"accessor property '\"+name+\"' without getter\");\n          }\n        }\n      }\n    }\n\n    return res;\n  },\n\n  /**\n   * If name denotes a fixed non-configurable, non-writable data property,\n   * check that the trap rejects the assignment.\n   */\n  set: function(receiver, name, val) {\n    var trap = this.getTrap(\"set\");\n    if (trap === undefined) {\n      // default forwarding behavior\n      return Reflect.set(this.target, name, val, receiver);\n    }\n\n    name = String(name);\n    var res = trap.call(this.handler, this.target, name, val, receiver);\n    res = !!res; // coerce to Boolean\n\n    // if success is reported, check whether property is truly assignable\n    if (res === true) {\n      var fixedDesc = Object.getOwnPropertyDescriptor(this.target, name);\n      if (fixedDesc !== undefined) { // setting an existing property\n        if (isDataDescriptor(fixedDesc) &&\n            fixedDesc.configurable === false &&\n            fixedDesc.writable === false) {\n          if (!sameValue(val, fixedDesc.value)) {\n            throw new TypeError(\"cannot successfully assign to a \"+\n                                \"non-writable, non-configurable property '\"+\n                                name+\"'\");\n          }\n        } else {\n          if (isAccessorDescriptor(fixedDesc) &&\n              fixedDesc.configurable === false && // non-configurable\n              fixedDesc.set === undefined) {      // accessor with undefined setter\n            throw new TypeError(\"setting a property '\"+name+\"' that has \"+\n                                \" only a getter\");\n          }\n        }\n      }\n    }\n\n    return res;\n  },\n\n  /**\n   * Any own enumerable non-configurable properties of the target that are not\n   * included in the trap result give rise to a TypeError. As such, we check\n   * whether the returned result contains at least all sealed enumerable properties\n   * of the target object.\n   *\n   * The trap should return an iterator.\n   *\n   * However, as implementations of pre-direct proxies still expect enumerate\n   * to return an array of strings, we convert the iterator into an array.\n   */\n  enumerate: function() {\n    var trap = this.getTrap(\"enumerate\");\n    if (trap === undefined) {\n      // default forwarding behavior\n      var trapResult = Reflect.enumerate(this.target);\n      var result = [];\n      var nxt = trapResult.next();\n      while (!nxt.done) {\n        result.push(String(nxt.value));\n        nxt = trapResult.next();\n      }\n      return result;\n    }\n\n    var trapResult = trap.call(this.handler, this.target);\n    \n    if (trapResult === null ||\n        trapResult === undefined ||\n        trapResult.next === undefined) {\n      throw new TypeError(\"enumerate trap should return an iterator, got: \"+\n                          trapResult);    \n    }\n    \n    // propNames is used as a set of strings\n    var propNames = Object.create(null);\n    \n    // var numProps = +trapResult.length;\n    var result = []; // new Array(numProps);\n    \n    // trapResult is supposed to be an iterator\n    // drain iterator to array as current implementations still expect\n    // enumerate to return an array of strings\n    var nxt = trapResult.next();\n    \n    while (!nxt.done) {\n      var s = String(nxt.value);\n      if (propNames[s]) {\n        throw new TypeError(\"enumerate trap cannot list a \"+\n                            \"duplicate property '\"+s+\"'\");\n      }\n      propNames[s] = true;\n      result.push(s);\n      nxt = trapResult.next();\n    }\n    \n    /*for (var i = 0; i < numProps; i++) {\n      var s = String(trapResult[i]);\n      if (propNames[s]) {\n        throw new TypeError(\"enumerate trap cannot list a \"+\n                            \"duplicate property '\"+s+\"'\");\n      }\n\n      propNames[s] = true;\n      result[i] = s;\n    } */\n\n    var ownEnumerableProps = Object.keys(this.target);\n    var target = this.target;\n    ownEnumerableProps.forEach(function (ownEnumerableProp) {\n      if (!propNames[ownEnumerableProp]) {\n        if (isSealed(ownEnumerableProp, target)) {\n          throw new TypeError(\"enumerate trap failed to include \"+\n                              \"non-configurable enumerable property '\"+\n                              ownEnumerableProp+\"'\");\n        }\n        if (!Object.isExtensible(target) &&\n            isFixed(ownEnumerableProp, target)) {\n            // if handler is allowed not to report ownEnumerableProp as an own\n            // property, we cannot guarantee that it will never report it as\n            // an own property later. Once a property has been reported as\n            // non-existent on a non-extensible object, it should forever be\n            // reported as non-existent\n            throw new TypeError(\"cannot report existing own property '\"+\n                                ownEnumerableProp+\"' as non-existent on a \"+\n                                \"non-extensible object\");\n        }\n      }\n    });\n\n    return result;\n  },\n\n  /**\n   * The iterate trap is deprecated by the enumerate trap.\n   */\n  iterate: Validator.prototype.enumerate,\n\n  /**\n   * Any own non-configurable properties of the target that are not included\n   * in the trap result give rise to a TypeError. As such, we check whether the\n   * returned result contains at least all sealed properties of the target\n   * object.\n   *\n   * The trap result is normalized.\n   * The trap result is not returned directly. Instead:\n   *  - create and return a fresh Array,\n   *  - of which each element is coerced to String,\n   *  - which does not contain duplicates\n   *\n   * FIXME: keys trap is deprecated\n   */\n  /*\n  keys: function() {\n    var trap = this.getTrap(\"keys\");\n    if (trap === undefined) {\n      // default forwarding behavior\n      return Reflect.keys(this.target);\n    }\n\n    var trapResult = trap.call(this.handler, this.target);\n\n    // propNames is used as a set of strings\n    var propNames = Object.create(null);\n    var numProps = +trapResult.length;\n    var result = new Array(numProps);\n\n    for (var i = 0; i < numProps; i++) {\n     var s = String(trapResult[i]);\n     if (propNames[s]) {\n       throw new TypeError(\"keys trap cannot list a \"+\n                           \"duplicate property '\"+s+\"'\");\n     }\n     if (!Object.isExtensible(this.target) && !isFixed(s, this.target)) {\n       // non-extensible proxies don't tolerate new own property names\n       throw new TypeError(\"keys trap cannot list a new \"+\n                           \"property '\"+s+\"' on a non-extensible object\");\n     }\n\n     propNames[s] = true;\n     result[i] = s;\n    }\n\n    var ownEnumerableProps = Object.keys(this.target);\n    var target = this.target;\n    ownEnumerableProps.forEach(function (ownEnumerableProp) {\n      if (!propNames[ownEnumerableProp]) {\n        if (isSealed(ownEnumerableProp, target)) {\n          throw new TypeError(\"keys trap failed to include \"+\n                              \"non-configurable enumerable property '\"+\n                              ownEnumerableProp+\"'\");\n        }\n        if (!Object.isExtensible(target) &&\n            isFixed(ownEnumerableProp, target)) {\n            // if handler is allowed not to report ownEnumerableProp as an own\n            // property, we cannot guarantee that it will never report it as\n            // an own property later. Once a property has been reported as\n            // non-existent on a non-extensible object, it should forever be\n            // reported as non-existent\n            throw new TypeError(\"cannot report existing own property '\"+\n                                ownEnumerableProp+\"' as non-existent on a \"+\n                                \"non-extensible object\");\n        }\n      }\n    });\n\n    return result;\n  },\n  */\n  \n  /**\n   * New trap that reifies [[Call]].\n   * If the target is a function, then a call to\n   *   proxy(...args)\n   * Triggers this trap\n   */\n  apply: function(target, thisBinding, args) {\n    var trap = this.getTrap(\"apply\");\n    if (trap === undefined) {\n      return Reflect.apply(target, thisBinding, args);\n    }\n\n    if (typeof this.target === \"function\") {\n      return trap.call(this.handler, target, thisBinding, args);\n    } else {\n      throw new TypeError(\"apply: \"+ target + \" is not a function\");\n    }\n  },\n\n  /**\n   * New trap that reifies [[Construct]].\n   * If the target is a function, then a call to\n   *   new proxy(...args)\n   * Triggers this trap\n   */\n  construct: function(target, args, newTarget) {\n    var trap = this.getTrap(\"construct\");\n    if (trap === undefined) {\n      return Reflect.construct(target, args, newTarget);\n    }\n\n    if (typeof target !== \"function\") {\n      throw new TypeError(\"new: \"+ target + \" is not a function\");\n    }\n\n    if (newTarget === undefined) {\n      newTarget = target;\n    } else {\n      if (typeof newTarget !== \"function\") {\n        throw new TypeError(\"new: \"+ newTarget + \" is not a function\");\n      }      \n    }\n    return trap.call(this.handler, target, args, newTarget);\n  }\n};\n\n// ---- end of the Validator handler wrapper handler ----\n\n// In what follows, a 'direct proxy' is a proxy\n// whose handler is a Validator. Such proxies can be made non-extensible,\n// sealed or frozen without losing the ability to trap.\n\n// maps direct proxies to their Validator handlers\nvar directProxies = new WeakMap();\n\n// patch Object.{preventExtensions,seal,freeze} so that\n// they recognize fixable proxies and act accordingly\nObject.preventExtensions = function(subject) {\n  var vhandler = directProxies.get(subject);\n  if (vhandler !== undefined) {\n    if (vhandler.preventExtensions()) {\n      return subject;\n    } else {\n      throw new TypeError(\"preventExtensions on \"+subject+\" rejected\");\n    }\n  } else {\n    return prim_preventExtensions(subject);\n  }\n};\nObject.seal = function(subject) {\n  setIntegrityLevel(subject, \"sealed\");\n  return subject;\n};\nObject.freeze = function(subject) {\n  setIntegrityLevel(subject, \"frozen\");\n  return subject;\n};\nObject.isExtensible = Object_isExtensible = function(subject) {\n  var vHandler = directProxies.get(subject);\n  if (vHandler !== undefined) {\n    return vHandler.isExtensible();\n  } else {\n    return prim_isExtensible(subject);\n  }\n};\nObject.isSealed = Object_isSealed = function(subject) {\n  return testIntegrityLevel(subject, \"sealed\");\n};\nObject.isFrozen = Object_isFrozen = function(subject) {\n  return testIntegrityLevel(subject, \"frozen\");\n};\nObject.getPrototypeOf = Object_getPrototypeOf = function(subject) {\n  var vHandler = directProxies.get(subject);\n  if (vHandler !== undefined) {\n    return vHandler.getPrototypeOf();\n  } else {\n    return prim_getPrototypeOf(subject);\n  }\n};\n\n// patch Object.getOwnPropertyDescriptor to directly call\n// the Validator.prototype.getOwnPropertyDescriptor trap\n// This is to circumvent an assertion in the built-in Proxy\n// trapping mechanism of v8, which disallows that trap to\n// return non-configurable property descriptors (as per the\n// old Proxy design)\nObject.getOwnPropertyDescriptor = function(subject, name) {\n  var vhandler = directProxies.get(subject);\n  if (vhandler !== undefined) {\n    return vhandler.getOwnPropertyDescriptor(name);\n  } else {\n    return prim_getOwnPropertyDescriptor(subject, name);\n  }\n};\n\n// patch Object.defineProperty to directly call\n// the Validator.prototype.defineProperty trap\n// This is to circumvent two issues with the built-in\n// trap mechanism:\n// 1) the current tracemonkey implementation of proxies\n// auto-completes 'desc', which is not correct. 'desc' should be\n// normalized, but not completed. Consider:\n// Object.defineProperty(proxy, 'foo', {enumerable:false})\n// This trap will receive desc =\n//  {value:undefined,writable:false,enumerable:false,configurable:false}\n// This will also set all other attributes to their default value,\n// which is unexpected and different from [[DefineOwnProperty]].\n// Bug filed: https://bugzilla.mozilla.org/show_bug.cgi?id=601329\n// 2) the current spidermonkey implementation does not\n// throw an exception when this trap returns 'false', but instead silently\n// ignores the operation (this is regardless of strict-mode)\n// 2a) v8 does throw an exception for this case, but includes the rather\n//     unhelpful error message:\n// 'Proxy handler #<Object> returned false from 'defineProperty' trap'\nObject.defineProperty = function(subject, name, desc) {\n  var vhandler = directProxies.get(subject);\n  if (vhandler !== undefined) {\n    var normalizedDesc = normalizePropertyDescriptor(desc);\n    var success = vhandler.defineProperty(name, normalizedDesc);\n    if (success === false) {\n      throw new TypeError(\"can't redefine property '\"+name+\"'\");\n    }\n    return subject;\n  } else {\n    return prim_defineProperty(subject, name, desc);\n  }\n};\n\nObject.defineProperties = function(subject, descs) {\n  var vhandler = directProxies.get(subject);\n  if (vhandler !== undefined) {\n    var names = Object.keys(descs);\n    for (var i = 0; i < names.length; i++) {\n      var name = names[i];\n      var normalizedDesc = normalizePropertyDescriptor(descs[name]);\n      var success = vhandler.defineProperty(name, normalizedDesc);\n      if (success === false) {\n        throw new TypeError(\"can't redefine property '\"+name+\"'\");\n      }\n    }\n    return subject;\n  } else {\n    return prim_defineProperties(subject, descs);\n  }\n};\n\nObject.keys = function(subject) {\n  var vHandler = directProxies.get(subject);\n  if (vHandler !== undefined) {\n    var ownKeys = vHandler.ownKeys();\n    var result = [];\n    for (var i = 0; i < ownKeys.length; i++) {\n      var k = String(ownKeys[i]);\n      var desc = Object.getOwnPropertyDescriptor(subject, k);\n      if (desc !== undefined && desc.enumerable === true) {\n        result.push(k);\n      }\n    }\n    return result;\n  } else {\n    return prim_keys(subject);\n  }\n}\n\nObject.getOwnPropertyNames = Object_getOwnPropertyNames = function(subject) {\n  var vHandler = directProxies.get(subject);\n  if (vHandler !== undefined) {\n    return vHandler.ownKeys();\n  } else {\n    return prim_getOwnPropertyNames(subject);\n  }\n}\n\n// fixes issue #71 (Calling Object.getOwnPropertySymbols() on a Proxy\n// throws an error)\nif (prim_getOwnPropertySymbols !== undefined) {\n  Object.getOwnPropertySymbols = function(subject) {\n    var vHandler = directProxies.get(subject);\n    if (vHandler !== undefined) {\n      // as this shim does not support symbols, a Proxy never advertises\n      // any symbol-valued own properties\n      return [];\n    } else {\n      return prim_getOwnPropertySymbols(subject);\n    }\n  };\n}\n\n// fixes issue #72 ('Illegal access' error when using Object.assign)\n// Object.assign polyfill based on a polyfill posted on MDN: \n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/\\\n//  Global_Objects/Object/assign\n// Note that this polyfill does not support Symbols, but this Proxy Shim\n// does not support Symbols anyway.\nif (prim_assign !== undefined) {\n  Object.assign = function (target) {\n    \n    // check if any argument is a proxy object\n    var noProxies = true;\n    for (var i = 0; i < arguments.length; i++) {\n      var vHandler = directProxies.get(arguments[i]);\n      if (vHandler !== undefined) {\n        noProxies = false;\n        break;\n      }\n    }\n    if (noProxies) {\n      // not a single argument is a proxy, perform built-in algorithm\n      return prim_assign.apply(Object, arguments);\n    }\n    \n    // there is at least one proxy argument, use the polyfill\n    \n    if (target === undefined || target === null) {\n      throw new TypeError('Cannot convert undefined or null to object');\n    }\n\n    var output = Object(target);\n    for (var index = 1; index < arguments.length; index++) {\n      var source = arguments[index];\n      if (source !== undefined && source !== null) {\n        for (var nextKey in source) {\n          if (source.hasOwnProperty(nextKey)) {\n            output[nextKey] = source[nextKey];\n          }\n        }\n      }\n    }\n    return output;\n  };\n}\n\n// returns whether an argument is a reference to an object,\n// which is legal as a WeakMap key.\nfunction isObject(arg) {\n  var type = typeof arg;\n  return (type === 'object' && arg !== null) || (type === 'function');\n};\n\n// a wrapper for WeakMap.get which returns the undefined value\n// for keys that are not objects (in which case the underlying\n// WeakMap would have thrown a TypeError).\nfunction safeWeakMapGet(map, key) {\n  return isObject(key) ? map.get(key) : undefined;\n};\n\n// returns a new function of zero arguments that recursively\n// unwraps any proxies specified as the |this|-value.\n// The primitive is assumed to be a zero-argument method\n// that uses its |this|-binding.\nfunction makeUnwrapping0ArgMethod(primitive) {\n  return function builtin() {\n    var vHandler = safeWeakMapGet(directProxies, this);\n    if (vHandler !== undefined) {\n      return builtin.call(vHandler.target);\n    } else {\n      return primitive.call(this);\n    }\n  }\n};\n\n// returns a new function of 1 arguments that recursively\n// unwraps any proxies specified as the |this|-value.\n// The primitive is assumed to be a 1-argument method\n// that uses its |this|-binding.\nfunction makeUnwrapping1ArgMethod(primitive) {\n  return function builtin(arg) {\n    var vHandler = safeWeakMapGet(directProxies, this);\n    if (vHandler !== undefined) {\n      return builtin.call(vHandler.target, arg);\n    } else {\n      return primitive.call(this, arg);\n    }\n  }\n};\n\nObject.prototype.valueOf =\n  makeUnwrapping0ArgMethod(Object.prototype.valueOf);\nObject.prototype.toString =\n  makeUnwrapping0ArgMethod(Object.prototype.toString);\nFunction.prototype.toString =\n  makeUnwrapping0ArgMethod(Function.prototype.toString);\nDate.prototype.toString =\n  makeUnwrapping0ArgMethod(Date.prototype.toString);\n\nObject.prototype.isPrototypeOf = function builtin(arg) {\n  // bugfix thanks to Bill Mark:\n  // built-in isPrototypeOf does not unwrap proxies used\n  // as arguments. So, we implement the builtin ourselves,\n  // based on the ECMAScript 6 spec. Our encoding will\n  // make sure that if a proxy is used as an argument,\n  // its getPrototypeOf trap will be called.\n  while (true) {\n    var vHandler2 = safeWeakMapGet(directProxies, arg);\n    if (vHandler2 !== undefined) {\n      arg = vHandler2.getPrototypeOf();\n      if (arg === null) {\n        return false;\n      } else if (sameValue(arg, this)) {\n        return true;\n      }\n    } else {\n      return prim_isPrototypeOf.call(this, arg);\n    }\n  }\n};\n\nArray.isArray = function(subject) {\n  var vHandler = safeWeakMapGet(directProxies, subject);\n  if (vHandler !== undefined) {\n    return Array.isArray(vHandler.target);\n  } else {\n    return prim_isArray(subject);\n  }\n};\n\nfunction isProxyArray(arg) {\n  var vHandler = safeWeakMapGet(directProxies, arg);\n  if (vHandler !== undefined) {\n    return Array.isArray(vHandler.target);\n  }\n  return false;\n}\n\n// Array.prototype.concat internally tests whether one of its\n// arguments is an Array, by checking whether [[Class]] == \"Array\"\n// As such, it will fail to recognize proxies-for-arrays as arrays.\n// We patch Array.prototype.concat so that it \"unwraps\" proxies-for-arrays\n// by making a copy. This will trigger the exact same sequence of\n// traps on the proxy-for-array as if we would not have unwrapped it.\n// See <https://github.com/tvcutsem/harmony-reflect/issues/19> for more.\nArray.prototype.concat = function(/*...args*/) {\n  var length;\n  for (var i = 0; i < arguments.length; i++) {\n    if (isProxyArray(arguments[i])) {\n      length = arguments[i].length;\n      arguments[i] = Array.prototype.slice.call(arguments[i], 0, length);\n    }\n  }\n  return prim_concat.apply(this, arguments);\n};\n\n// setPrototypeOf support on platforms that support __proto__\n\nvar prim_setPrototypeOf = Object.setPrototypeOf;\n\n// patch and extract original __proto__ setter\nvar __proto__setter = (function() {\n  var protoDesc = prim_getOwnPropertyDescriptor(Object.prototype,'__proto__');\n  if (protoDesc === undefined ||\n      typeof protoDesc.set !== \"function\") {\n    return function() {\n      throw new TypeError(\"setPrototypeOf not supported on this platform\");\n    }\n  }\n\n  // see if we can actually mutate a prototype with the generic setter\n  // (e.g. Chrome v28 doesn't allow setting __proto__ via the generic setter)\n  try {\n    protoDesc.set.call({},{});\n  } catch (e) {\n    return function() {\n      throw new TypeError(\"setPrototypeOf not supported on this platform\");\n    }\n  }\n\n  prim_defineProperty(Object.prototype, '__proto__', {\n    set: function(newProto) {\n      return Object.setPrototypeOf(this, Object(newProto));\n    }\n  });\n\n  return protoDesc.set;\n}());\n\nObject.setPrototypeOf = function(target, newProto) {\n  var handler = directProxies.get(target);\n  if (handler !== undefined) {\n    if (handler.setPrototypeOf(newProto)) {\n      return target;\n    } else {\n      throw new TypeError(\"proxy rejected prototype mutation\");\n    }\n  } else {\n    if (!Object_isExtensible(target)) {\n      throw new TypeError(\"can't set prototype on non-extensible object: \" +\n                          target);\n    }\n    if (prim_setPrototypeOf)\n      return prim_setPrototypeOf(target, newProto);\n\n    if (Object(newProto) !== newProto || newProto === null) {\n      throw new TypeError(\"Object prototype may only be an Object or null: \" +\n                         newProto);\n      // throw new TypeError(\"prototype must be an object or null\")\n    }\n    __proto__setter.call(target, newProto);\n    return target;\n  }\n}\n\nObject.prototype.hasOwnProperty = function(name) {\n  var handler = safeWeakMapGet(directProxies, this);\n  if (handler !== undefined) {\n    var desc = handler.getOwnPropertyDescriptor(name);\n    return desc !== undefined;\n  } else {\n    return prim_hasOwnProperty.call(this, name);\n  }\n}\n\n// ============= Reflection module =============\n// see http://wiki.ecmascript.org/doku.php?id=harmony:reflect_api\n\nvar Reflect = global.Reflect = {\n  getOwnPropertyDescriptor: function(target, name) {\n    return Object.getOwnPropertyDescriptor(target, name);\n  },\n  defineProperty: function(target, name, desc) {\n\n    // if target is a proxy, invoke its \"defineProperty\" trap\n    var handler = directProxies.get(target);\n    if (handler !== undefined) {\n      return handler.defineProperty(target, name, desc);\n    }\n\n    // Implementation transliterated from [[DefineOwnProperty]]\n    // see ES5.1 section 8.12.9\n    // this is the _exact same algorithm_ as the isCompatibleDescriptor\n    // algorithm defined above, except that at every place it\n    // returns true, this algorithm actually does define the property.\n    var current = Object.getOwnPropertyDescriptor(target, name);\n    var extensible = Object.isExtensible(target);\n    if (current === undefined && extensible === false) {\n      return false;\n    }\n    if (current === undefined && extensible === true) {\n      Object.defineProperty(target, name, desc); // should never fail\n      return true;\n    }\n    if (isEmptyDescriptor(desc)) {\n      return true;\n    }\n    if (isEquivalentDescriptor(current, desc)) {\n      return true;\n    }\n    if (current.configurable === false) {\n      if (desc.configurable === true) {\n        return false;\n      }\n      if ('enumerable' in desc && desc.enumerable !== current.enumerable) {\n        return false;\n      }\n    }\n    if (isGenericDescriptor(desc)) {\n      // no further validation necessary\n    } else if (isDataDescriptor(current) !== isDataDescriptor(desc)) {\n      if (current.configurable === false) {\n        return false;\n      }\n    } else if (isDataDescriptor(current) && isDataDescriptor(desc)) {\n      if (current.configurable === false) {\n        if (current.writable === false && desc.writable === true) {\n          return false;\n        }\n        if (current.writable === false) {\n          if ('value' in desc && !sameValue(desc.value, current.value)) {\n            return false;\n          }\n        }\n      }\n    } else if (isAccessorDescriptor(current) && isAccessorDescriptor(desc)) {\n      if (current.configurable === false) {\n        if ('set' in desc && !sameValue(desc.set, current.set)) {\n          return false;\n        }\n        if ('get' in desc && !sameValue(desc.get, current.get)) {\n          return false;\n        }\n      }\n    }\n    Object.defineProperty(target, name, desc); // should never fail\n    return true;\n  },\n  deleteProperty: function(target, name) {\n    var handler = directProxies.get(target);\n    if (handler !== undefined) {\n      return handler.delete(name);\n    }\n    \n    var desc = Object.getOwnPropertyDescriptor(target, name);\n    if (desc === undefined) {\n      return true;\n    }\n    if (desc.configurable === true) {\n      delete target[name];\n      return true;\n    }\n    return false;    \n  },\n  getPrototypeOf: function(target) {\n    return Object.getPrototypeOf(target);\n  },\n  setPrototypeOf: function(target, newProto) {\n    \n    var handler = directProxies.get(target);\n    if (handler !== undefined) {\n      return handler.setPrototypeOf(newProto);\n    }\n    \n    if (Object(newProto) !== newProto || newProto === null) {\n      throw new TypeError(\"Object prototype may only be an Object or null: \" +\n                         newProto);\n    }\n    \n    if (!Object_isExtensible(target)) {\n      return false;\n    }\n    \n    var current = Object.getPrototypeOf(target);\n    if (sameValue(current, newProto)) {\n      return true;\n    }\n    \n    if (prim_setPrototypeOf) {\n      try {\n        prim_setPrototypeOf(target, newProto);\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }\n\n    __proto__setter.call(target, newProto);\n    return true;\n  },\n  preventExtensions: function(target) {\n    var handler = directProxies.get(target);\n    if (handler !== undefined) {\n      return handler.preventExtensions();\n    }\n    prim_preventExtensions(target);\n    return true;\n  },\n  isExtensible: function(target) {\n    return Object.isExtensible(target);\n  },\n  has: function(target, name) {\n    return name in target;\n  },\n  get: function(target, name, receiver) {\n    receiver = receiver || target;\n\n    // if target is a proxy, invoke its \"get\" trap\n    var handler = directProxies.get(target);\n    if (handler !== undefined) {\n      return handler.get(receiver, name);\n    }\n\n    var desc = Object.getOwnPropertyDescriptor(target, name);\n    if (desc === undefined) {\n      var proto = Object.getPrototypeOf(target);\n      if (proto === null) {\n        return undefined;\n      }\n      return Reflect.get(proto, name, receiver);\n    }\n    if (isDataDescriptor(desc)) {\n      return desc.value;\n    }\n    var getter = desc.get;\n    if (getter === undefined) {\n      return undefined;\n    }\n    return desc.get.call(receiver);\n  },\n  // Reflect.set implementation based on latest version of [[SetP]] at\n  // http://wiki.ecmascript.org/doku.php?id=harmony:proto_climbing_refactoring\n  set: function(target, name, value, receiver) {\n    receiver = receiver || target;\n\n    // if target is a proxy, invoke its \"set\" trap\n    var handler = directProxies.get(target);\n    if (handler !== undefined) {\n      return handler.set(receiver, name, value);\n    }\n\n    // first, check whether target has a non-writable property\n    // shadowing name on receiver\n    var ownDesc = Object.getOwnPropertyDescriptor(target, name);\n\n    if (ownDesc === undefined) {\n      // name is not defined in target, search target's prototype\n      var proto = Object.getPrototypeOf(target);\n\n      if (proto !== null) {\n        // continue the search in target's prototype\n        return Reflect.set(proto, name, value, receiver);\n      }\n\n      // Rev16 change. Cf. https://bugs.ecmascript.org/show_bug.cgi?id=1549\n      // target was the last prototype, now we know that 'name' is not shadowed\n      // by an existing (accessor or data) property, so we can add the property\n      // to the initial receiver object\n      // (this branch will intentionally fall through to the code below)\n      ownDesc =\n        { value: undefined,\n          writable: true,\n          enumerable: true,\n          configurable: true };\n    }\n\n    // we now know that ownDesc !== undefined\n    if (isAccessorDescriptor(ownDesc)) {\n      var setter = ownDesc.set;\n      if (setter === undefined) return false;\n      setter.call(receiver, value); // assumes Function.prototype.call\n      return true;\n    }\n    // otherwise, isDataDescriptor(ownDesc) must be true\n    if (ownDesc.writable === false) return false;\n    // we found an existing writable data property on the prototype chain.\n    // Now update or add the data property on the receiver, depending on\n    // whether the receiver already defines the property or not.\n    var existingDesc = Object.getOwnPropertyDescriptor(receiver, name);\n    if (existingDesc !== undefined) {\n      var updateDesc =\n        { value: value,\n          // FIXME: it should not be necessary to describe the following\n          // attributes. Added to circumvent a bug in tracemonkey:\n          // https://bugzilla.mozilla.org/show_bug.cgi?id=601329\n          writable:     existingDesc.writable,\n          enumerable:   existingDesc.enumerable,\n          configurable: existingDesc.configurable };\n      Object.defineProperty(receiver, name, updateDesc);\n      return true;\n    } else {\n      if (!Object.isExtensible(receiver)) return false;\n      var newDesc =\n        { value: value,\n          writable: true,\n          enumerable: true,\n          configurable: true };\n      Object.defineProperty(receiver, name, newDesc);\n      return true;\n    }\n  },\n  /*invoke: function(target, name, args, receiver) {\n    receiver = receiver || target;\n\n    var handler = directProxies.get(target);\n    if (handler !== undefined) {\n      return handler.invoke(receiver, name, args);\n    }\n\n    var fun = Reflect.get(target, name, receiver);\n    return Function.prototype.apply.call(fun, receiver, args);\n  },*/\n  enumerate: function(target) {\n    var handler = directProxies.get(target);\n    var result;\n    if (handler !== undefined) {\n      // handler.enumerate should return an iterator directly, but the\n      // iterator gets converted to an array for backward-compat reasons,\n      // so we must re-iterate over the array\n      result = handler.enumerate(handler.target);\n    } else {\n      result = [];\n      for (var name in target) { result.push(name); };      \n    }\n    var l = +result.length;\n    var idx = 0;\n    return {\n      next: function() {\n        if (idx === l) return { done: true };\n        return { done: false, value: result[idx++] };\n      }\n    };\n  },\n  // imperfect ownKeys implementation: in ES6, should also include\n  // symbol-keyed properties.\n  ownKeys: function(target) {\n    return Object_getOwnPropertyNames(target);\n  },\n  apply: function(target, receiver, args) {\n    // target.apply(receiver, args)\n    return Function.prototype.apply.call(target, receiver, args);\n  },\n  construct: function(target, args, newTarget) {\n    // return new target(...args);\n\n    // if target is a proxy, invoke its \"construct\" trap\n    var handler = directProxies.get(target);\n    if (handler !== undefined) {\n      return handler.construct(handler.target, args, newTarget);\n    }\n    \n    if (typeof target !== \"function\") {\n      throw new TypeError(\"target is not a function: \" + target);\n    }\n    if (newTarget === undefined) {\n      newTarget = target;\n    } else {\n      if (typeof newTarget !== \"function\") {\n        throw new TypeError(\"newTarget is not a function: \" + target);\n      }      \n    }\n\n    return new (Function.prototype.bind.apply(newTarget, [null].concat(args)));\n  }\n};\n\n// feature-test whether the Proxy global exists, with\n// the harmony-era Proxy.create API\nif (typeof Proxy !== \"undefined\" &&\n    typeof Proxy.create !== \"undefined\") {\n\n  var primCreate = Proxy.create,\n      primCreateFunction = Proxy.createFunction;\n\n  var revokedHandler = primCreate({\n    get: function() { throw new TypeError(\"proxy is revoked\"); }\n  });\n\n  global.Proxy = function(target, handler) {\n    // check that target is an Object\n    if (Object(target) !== target) {\n      throw new TypeError(\"Proxy target must be an Object, given \"+target);\n    }\n    // check that handler is an Object\n    if (Object(handler) !== handler) {\n      throw new TypeError(\"Proxy handler must be an Object, given \"+handler);\n    }\n\n    var vHandler = new Validator(target, handler);\n    var proxy;\n    if (typeof target === \"function\") {\n      proxy = primCreateFunction(vHandler,\n        // call trap\n        function() {\n          var args = Array.prototype.slice.call(arguments);\n          return vHandler.apply(target, this, args);\n        },\n        // construct trap\n        function() {\n          var args = Array.prototype.slice.call(arguments);\n          return vHandler.construct(target, args);\n        });\n    } else {\n      proxy = primCreate(vHandler, Object.getPrototypeOf(target));\n    }\n    directProxies.set(proxy, vHandler);\n    return proxy;\n  };\n\n  global.Proxy.revocable = function(target, handler) {\n    var proxy = new Proxy(target, handler);\n    var revoke = function() {\n      var vHandler = directProxies.get(proxy);\n      if (vHandler !== null) {\n        vHandler.target  = null;\n        vHandler.handler = revokedHandler;\n      }\n      return undefined;\n    };\n    return {proxy: proxy, revoke: revoke};\n  }\n  \n  // add the old Proxy.create and Proxy.createFunction methods\n  // so old code that still depends on the harmony-era Proxy object\n  // is not broken. Also ensures that multiple versions of this\n  // library should load fine\n  global.Proxy.create = primCreate;\n  global.Proxy.createFunction = primCreateFunction;\n\n} else {\n  // Proxy global not defined, or old API not available\n  if (typeof Proxy === \"undefined\") {\n    // Proxy global not defined, add a Proxy function stub\n    global.Proxy = function(_target, _handler) {\n      throw new Error(\"proxies not supported on this platform. On v8/node/iojs, make sure to pass the --harmony_proxies flag\");\n    };\n  }\n  // Proxy global defined but old API not available\n  // presumably Proxy global already supports new API, leave untouched\n}\n\n// for node.js modules, export every property in the Reflect object\n// as part of the module interface\nif (typeof exports !== 'undefined') {\n  Object.keys(Reflect).forEach(function (key) {\n    exports[key] = Reflect[key];\n  });\n}\n\n// function-as-module pattern\n}(typeof exports !== 'undefined' ? global : this));\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../node_modules/harmony-reflect/reflect.js\n// module id = 246\n// module chunks = 4","var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../node_modules/webpack/buildin/global.js\n// module id = 260\n// module chunks = 0 3 4"],"sourceRoot":""}